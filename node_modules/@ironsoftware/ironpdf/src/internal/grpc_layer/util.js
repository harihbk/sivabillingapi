"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImageExtType = exports.getFileNames = exports.PdfPageSelectionToIndexes = exports.AsyncPdfPageSelectionToIndexes = exports.handleEmptyResultP__Output = exports.handlePdfDocumentResultP__Output = exports.separateImageBufferOrImagePathInput = exports.separatePdfInput = exports.fileToBuffer = exports.bufferToFile = exports.chunkBuffer = exports.chunkString = exports.CHUNK_SIZE = exports.handleRemoteException = void 0;
const buffer_1 = require("buffer");
const path_1 = __importDefault(require("path"));
const pdfDocument_1 = require("../../public/pdfDocument");
const image_1 = require("../../public/image");
const page_1 = require("./pdfium/page");
function handleRemoteException(proto, reject) {
    reject(`${proto.exceptionType} ${proto.message} \n ${proto.remoteStackTrace} \n ${proto.rootException}`);
}
exports.handleRemoteException = handleRemoteException;
exports.CHUNK_SIZE = 65536;
function chunkString(str) {
    return str.match(/.{1,65536}/g);
}
exports.chunkString = chunkString;
function chunkBuffer(buffer) {
    const chunks = [];
    for (let i = 0; i < buffer.length; i += exports.CHUNK_SIZE) {
        const chunk = buffer.subarray(i, i + exports.CHUNK_SIZE);
        chunks.push(chunk);
    }
    return chunks;
}
exports.chunkBuffer = chunkBuffer;
function bufferToFile(buffer) {
    // use to save files to disk locally.  Don't use IronPDfEngine as teh files will be saved remotely if using Docker
    throw new Error("Method not implemented.");
}
exports.bufferToFile = bufferToFile;
function fileToBuffer(filePath) {
    throw new Error("Method not implemented.");
}
exports.fileToBuffer = fileToBuffer;
const urlPattern = new RegExp("^(https?:\\/\\/)?" + // validate protocol
    "((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|" + // validate domain name
    "((\\d{1,3}\\.){3}\\d{1,3}))" + // validate OR ip (v4) address
    "(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*" + // validate port and path
    "(\\?[;&a-z\\d%_.~+=-]*)?" + // validate query string
    "(\\#[-a-z\\d_]*)?$", "i"); // validate fragment locator
function isValidUrl(urlString) {
    return urlPattern.test(urlString);
}
function separatePdfInput(input) {
    if (typeof input === "string") {
        if (input.endsWith(".html") || input.endsWith(".htm")) {
            return { type: "htmlFile", htmlFile: input };
        }
        else if (input.endsWith(".pdf")) {
            return { type: "pdfFile", pdfFile: input };
        }
        else if (input.endsWith(".zip")) {
            return { type: "zipFile", zipFile: input };
        }
        else if (input.indexOf("<") > -1) {
            return { type: "htmlString", htmlString: input };
        }
        else if (isValidUrl(input)) {
            return { type: "url", url: new URL(input) };
        }
        else {
            return { type: "htmlString", htmlString: input };
        }
    }
    else if (input instanceof buffer_1.Buffer) {
        return { type: "buffer", buffer: input };
    }
    else if (input instanceof URL) {
        return { type: "url", url: input };
    }
    else if (input instanceof pdfDocument_1.PdfDocument)
        return { type: "pdfDocument", pdfDocument: input };
    throw new Error(`unknown input : ${input}`);
}
exports.separatePdfInput = separatePdfInput;
function separateImageBufferOrImagePathInput(input) {
    if (typeof input === "string") {
        return { type: "imageFilePath", imageFilePath: input };
    }
    else if (input instanceof buffer_1.Buffer) {
        return { type: "imageBuffer", imageBuffer: input };
    }
    throw new Error(`unknown input : ${input}`);
}
exports.separateImageBufferOrImagePathInput = separateImageBufferOrImagePathInput;
function handlePdfDocumentResultP__Output(proto, resolve, reject) {
    if (proto) {
        if (proto === null || proto === void 0 ? void 0 : proto.exception) {
            handleRemoteException(proto.exception, reject);
        }
        if (proto.result) {
            resolve(proto.result.documentId);
        }
    }
    // throw new Error("Error empty message");
}
exports.handlePdfDocumentResultP__Output = handlePdfDocumentResultP__Output;
function handleEmptyResultP__Output(proto, reject) {
    if (proto === null || proto === void 0 ? void 0 : proto.exception) {
        handleRemoteException(proto.exception, reject);
    }
}
exports.handleEmptyResultP__Output = handleEmptyResultP__Output;
function AsyncPdfPageSelectionToIndexes(documentId, pdfPageSelection) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = pdfPageSelection
            ? typeof pdfPageSelection === "number"
                ? [pdfPageSelection]
                : Array.isArray(pdfPageSelection)
                    ? pdfPageSelection
                    : []
            : [];
        if (result.length == 0) {
            return Array.from({
                length: (yield (0, page_1.getPageInfo)(documentId)).length,
            }).map((value, index) => index);
        }
        return result;
    });
}
exports.AsyncPdfPageSelectionToIndexes = AsyncPdfPageSelectionToIndexes;
function PdfPageSelectionToIndexes(documentId, pagesInfo, pdfPageSelection) {
    const result = pdfPageSelection
        ? typeof pdfPageSelection === "number"
            ? [pdfPageSelection]
            : Array.isArray(pdfPageSelection)
                ? pdfPageSelection
                : []
        : [];
    if (result.length == 0) {
        return Array.from({
            length: pagesInfo.length,
        }).map((value, index) => index);
    }
    return result;
}
exports.PdfPageSelectionToIndexes = PdfPageSelectionToIndexes;
function getFileNames(filePath, fileCount, specificFileExt, defaultName = "output") {
    var _a;
    const directory = path_1.default.dirname(filePath);
    const extensionFromString = path_1.default.extname(filePath);
    const baseName = (_a = path_1.default.basename(filePath, extensionFromString)) !== null && _a !== void 0 ? _a : defaultName;
    let finalExtension = extensionFromString;
    if (specificFileExt && specificFileExt != extensionFromString) {
        finalExtension = extensionFromString + specificFileExt; // appended e.g. "c:/tmp/aa.jpg" -> "c:/tmp/aa.jpg.png"
    }
    if (fileCount == 1) {
        return [path_1.default.join(directory, `${baseName}${finalExtension}`)];
    }
    else {
        return Array.from({ length: fileCount }, (v, i) => i).map((index) => {
            return path_1.default.join(directory, `${baseName}_${index}${finalExtension}`);
        });
    }
}
exports.getFileNames = getFileNames;
function getImageExtType(imageType) {
    switch (imageType) {
        case image_1.ImageType.JPG:
            return ".jpg";
        case image_1.ImageType.BMP:
            return ".bmp";
        case image_1.ImageType.PNG:
            return ".png";
        default:
            return undefined;
    }
}
exports.getImageExtType = getImageExtType;
//# sourceMappingURL=util.js.map