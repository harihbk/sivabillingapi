"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergePdfs = exports.renderHtmlToPdf = exports.renderUrlToPdf = exports.renderHtmlZipToPdf = void 0;
const fs_1 = __importDefault(require("fs"));
const access_1 = require("../../access");
const util_1 = require("../util");
const converter_1 = require("./converter");
function renderHtmlZipToPdf(zipFilePath, mainHtmlFile = "Basic.html", renderOption, httpLoginCredentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            const stream = client.chromeRenderFromZipFile((err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
            stream.write({
                info: {
                    renderOptions: (0, converter_1.chromePdfRenderOptionsToProto)(renderOption),
                    httpOptions: (0, converter_1.httpLoginCredentialsToProto)(httpLoginCredentials),
                    mainFile: mainHtmlFile,
                },
            });
            const buf = fs_1.default.readFileSync(zipFilePath);
            if (buf) {
                (0, util_1.chunkBuffer)(buf).forEach((chunk) => {
                    stream.write({ zipChunk: chunk });
                });
            }
            stream.end();
        });
    });
}
exports.renderHtmlZipToPdf = renderHtmlZipToPdf;
function renderUrlToPdf(url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            const req = {
                uri: url.toString(),
                renderOptions: (0, converter_1.chromePdfRenderOptionsToProto)(options === null || options === void 0 ? void 0 : options.renderOptions),
                httpOptions: (0, converter_1.httpLoginCredentialsToProto)(options === null || options === void 0 ? void 0 : options.httpLoginCredentials),
            };
            client.Chrome_Render_FromUri(req, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
        });
    });
}
exports.renderUrlToPdf = renderUrlToPdf;
function renderHtmlToPdf(html, renderOption, httpLoginCredentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            const stream = client.Chrome_Render_FromHtml((err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
            const info = {
                renderOptions: (0, converter_1.chromePdfRenderOptionsToProto)(renderOption),
                httpOptions: (0, converter_1.httpLoginCredentialsToProto)(httpLoginCredentials),
            };
            stream.write({ info: info });
            const chunks = (0, util_1.chunkString)(html);
            chunks === null || chunks === void 0 ? void 0 : chunks.forEach((chunk) => {
                stream.write({ htmlChunk: chunk });
            });
            stream.end();
        });
    });
}
exports.renderHtmlToPdf = renderHtmlToPdf;
function mergePdfs(pdfIds) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            client.pdfiumPageMerge({
                documents: pdfIds.map((value) => ({ documentId: value })),
            }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
        });
    });
}
exports.mergePdfs = mergePdfs;
//# sourceMappingURL=render.js.map