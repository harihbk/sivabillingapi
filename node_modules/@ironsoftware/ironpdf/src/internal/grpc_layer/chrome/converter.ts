import {
	AffixFonts,
	BarcodeStampOptions,
	BarcodeType,
	BaseStampOptions,
	CssMediaType,
	CustomPaperSize,
	FitToPaperModes,
	HorizontalAlignment,
	HtmlStampOptions,
	ImageBehavior,
	ImageStampOptions,
	Length,
	MeasurementUnit,
	PageInfo,
	PdfPaperSize,
	PaperSizeUnit,
	PdfPageSelection,
	PdfPaperOrientation,
	PdfPassword,
	TextStampOptions,
	UseMargins,
	VerticalAlignment,
	WaitFor,
	WaitForType,
} from "../../../public/types";

import {ChromePdfRenderOptionsP} from "../../generated_proto/ironpdfengineproto/ChromePdfRenderOptionsP";
import {ChromeFitToPaperModesP} from "../../generated_proto/ironpdfengineproto/ChromeFitToPaperModesP";
import {ChromePdfPaperOrientationP} from "../../generated_proto/ironpdfengineproto/ChromePdfPaperOrientationP";
import {ChromePdfCssMediaTypeP} from "../../generated_proto/ironpdfengineproto/ChromePdfCssMediaTypeP";
import {ChromePdfPaperSizeP} from "../../generated_proto/ironpdfengineproto/ChromePdfPaperSizeP";
import {ChromeUseMarginsP} from "../../generated_proto/ironpdfengineproto/ChromeUseMarginsP";
import {ChromeHtmlHeaderFooterP} from "../../generated_proto/ironpdfengineproto/ChromeHtmlHeaderFooterP";
import {ChromeTextHeaderFooterP} from "../../generated_proto/ironpdfengineproto/ChromeTextHeaderFooterP";
import {FontTypeP} from "../../generated_proto/ironpdfengineproto/FontTypeP";
import {ChromeHttpLoginCredentialsP} from "../../generated_proto/ironpdfengineproto/ChromeHttpLoginCredentialsP";
import {PaperSize} from "../../../public/paper";
import {HtmlAffix, TextAffix} from "../../../public/affix";
import {
	ChromePdfRenderOptions,
	defaultChromePdfRenderOptions,
	HttpLoginCredentials,
} from "../../../public/render";
import {ChromeImageBehaviorP} from "../../generated_proto/ironpdfengineproto/ChromeImageBehaviorP";
import {PageRotationToProto} from "../pdfium/converter";
import {
	_ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP
} from "../../generated_proto/ironpdfengineproto/ChromeApplyStampRequestStreamP";
import {LengthP} from "../../generated_proto/ironpdfengineproto/LengthP";
import {MeasurementUnitP} from "../../generated_proto/ironpdfengineproto/MeasurementUnitP";
import {ChromeBarcodeEncodingP} from "../../generated_proto/ironpdfengineproto/ChromeBarcodeEncodingP";
import {VerticalAlignmentP} from "../../generated_proto/ironpdfengineproto/VerticalAlignmentP";
import {HorizontalAlignmentP} from "../../generated_proto/ironpdfengineproto/HorizontalAlignmentP";
import {PdfPageSelectionToIndexes} from "../util";
import {PdfiumPageP} from "../../generated_proto/ironpdfengineproto/PdfiumPageP";

export function fitToPaperModeToProto(
	fitToPaperMode?: FitToPaperModes
): ChromeFitToPaperModesP | undefined {
	if (!fitToPaperMode) return undefined;
	return {enumValue: fitToPaperMode};
}

export function PdfPaperOrientationToProto(
	pdfPaperOrientation?: PdfPaperOrientation
): ChromePdfPaperOrientationP | undefined {
	if (!pdfPaperOrientation) return undefined;
	return {enumValue: pdfPaperOrientation};
}

export function CssMediaTypeToProto(
	cssMediaType?: CssMediaType
): ChromePdfCssMediaTypeP | undefined {
	if (!cssMediaType) return undefined;
	return {enumValue: cssMediaType};
}

export function httpLoginCredentialsToProto(
	httpLoginCredentials?: HttpLoginCredentials
): ChromeHttpLoginCredentialsP | undefined {
	if (!httpLoginCredentials) return undefined;
	throw new Error("not implement");
}

interface WaitForDetail {
	type: number;
	timeout: number;
	networkIdleDuration: number;
	numAllowedInFlight: number;
	renderDelayDuration: number;
	htmlElementQueryStr: string;
}

export function convertWaitFor(waitFor: WaitFor | undefined): WaitForDetail {
	const defaultMaxWaitTime = 10000;
	const defaultNetworkIdleDuration = 500;
	const defaultNumAllowedInFlight = 0;
	const defaultRenderDelayDuration = 20;
	const defaultHtmlElementQueryStr = "";
	if (!waitFor) {
		return {
			type: 0,
			timeout: defaultMaxWaitTime,
			networkIdleDuration: defaultNetworkIdleDuration,
			numAllowedInFlight: defaultNumAllowedInFlight,
			renderDelayDuration: defaultRenderDelayDuration,
			htmlElementQueryStr: defaultHtmlElementQueryStr
		};
	}
	switch (waitFor.type) {
		case WaitForType.PageLoad:
			return {
				type: 0,
				timeout: defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};
		case WaitForType.JavaScript:
			return {
				type: 1,
				timeout: waitFor.maxWaitTime ?? defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};
		case WaitForType.RenderDelay:
			return {
				type: 2,
				timeout: defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration:
					waitFor.delay ?? defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};

		case WaitForType.NetworkIdle0:
			return {
				type: 3,
				timeout: waitFor.maxWaitTime ?? defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};
		case WaitForType.NetworkIdle2:
			return {
				type: 4,
				timeout: waitFor.maxWaitTime ?? defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};
		case WaitForType.NetworkIdleN:
			return {
				type: 5,
				timeout: waitFor.maxWaitTime ?? defaultMaxWaitTime,
				networkIdleDuration:
					waitFor.networkIdleDuration ?? defaultNetworkIdleDuration,
				numAllowedInFlight:
					waitFor.maxNumAllowedInflight ?? defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: defaultHtmlElementQueryStr
			};
		case WaitForType.HtmlElement:
			return {
				type: 6,
				timeout: waitFor.maxWaitTime ?? defaultMaxWaitTime,
				networkIdleDuration: defaultNetworkIdleDuration,
				numAllowedInFlight: defaultNumAllowedInFlight,
				renderDelayDuration: defaultRenderDelayDuration,
				htmlElementQueryStr: waitFor.htmlQueryStr
			};
	}
}

export function chromePdfRenderOptionsToProto(
	renderOption?: ChromePdfRenderOptions
): ChromePdfRenderOptionsP {
	if (!renderOption) renderOption = defaultChromePdfRenderOptions();

	const waitForDetail: WaitForDetail = convertWaitFor(renderOption.waitFor);

	const proto: ChromePdfRenderOptionsP = {
		createPdfFormsFromHtml: renderOption.createPdfFormsFromHtml,
		customCssUrl: renderOption.customCssUrl,
		enableJavaScript: renderOption.enableJavaScript,
		fitToPaperMode: fitToPaperModeToProto(renderOption.fitToPaperMode),
		grayScale: renderOption.grayScale,

		marginTop: renderOption.margin?.top || renderOption.margin?.default,
		marginBottom:
			renderOption.margin?.bottom || renderOption.margin?.default,
		marginLeft: renderOption.margin?.left || renderOption.margin?.default,
		marginRight: renderOption.margin?.right || renderOption.margin?.default,

		paperOrientation: PdfPaperOrientationToProto(
			renderOption.paperOrientation
		),

		printHtmlBackgrounds: renderOption.printHtmlBackgrounds,

		timeout: renderOption.timeout ?? 60,
		waitFor: {
			Type: waitForDetail.type,
			Timeout: waitForDetail.timeout,
			NetworkIdleDuration: waitForDetail.networkIdleDuration,
			NumAllowedInFlight: waitForDetail.numAllowedInFlight,
			RenderDelayDuration: waitForDetail.renderDelayDuration,
			HtmlElementQueryStr: waitForDetail.htmlElementQueryStr,
		},
		// WaitForNetworkIdleDuration: waitForDetail.networkIdleDuration,
		// WaitForType: waitForDetail.type,
		// WaitForNumAllowedInflight: waitForDetail.numAllowedInFlight,
		// WaitForTimeout: waitForDetail.timeout,

		title: renderOption.title,
		viewPortHeight: 1280,
		viewPortWidth: 1024,
		zoom: 100,
		inputEncoding: renderOption.inputEncoding,
		cssMediaType: CssMediaTypeToProto(renderOption.cssMediaType),
		javascript: renderOption.javascript,
		firstPageNumber: renderOption.firstPageNumber,

		useMarginsOnHeaderFooter: useMarginsToProto(
			renderOption.useMarginsOnHeaderAndFooter
		),
	};

	if (renderOption.htmlHeader) {
		proto.htmlHeader = htmlAffixToProto(renderOption.htmlHeader);
	}

	if (renderOption.htmlFooter) {
		proto.htmlFooter = htmlAffixToProto(renderOption.htmlFooter);
	}

	if (renderOption.textHeader) {
		proto.textHeader = textAffixToProto(renderOption.textHeader);
	}

	if (renderOption.textFooter) {
		proto.textFooter = textAffixToProto(renderOption.textFooter);
	}

	if (renderOption.paperSize) {
		if (pdfPaperSizeIsCustom(renderOption.paperSize)) {
			const wh = customPaperSizeToMm(
				renderOption.paperSize as CustomPaperSize
			);
			proto.customPaperHeight = wh.height;
			proto.customPaperWidth = wh.width;
			proto.paperSize = {enumValue: 106} //custom
		}else{
			proto.paperSize = paperSizeToProto(
				renderOption.paperSize as PaperSize
			);
		}
	}

	return proto;
}

export function pdfPaperSizeIsCustom(pdfPaperSize: PdfPaperSize) {
	if (
		pdfPaperSize instanceof Object &&
		"width" in pdfPaperSize &&
		"height" in pdfPaperSize &&
		"unit" in pdfPaperSize
	) {
		return true;
	} else {
		return false;
	}
}

export function htmlAffixToProto(
	htmlAffix?: HtmlAffix
): ChromeHtmlHeaderFooterP | undefined {
	if (!htmlAffix) return undefined;
	return {
		htmlFragment: htmlAffix.htmlFragment ?? "",
		// baseUrl: htmlAffix.baseUrl, //not supported
		dividerLineColor: htmlAffix.dividerLineColor ?? "#B1B1B1",
		drawDividerLine: htmlAffix.dividerLine ?? false,
		loadStylesAndCSSFromMainHtmlDocument:
			htmlAffix.loadStylesAndCSSFromMainHtmlDocument ?? false,
		maxHeight: htmlAffix.maxHeight ?? 176.388,
	};
}

export function textAffixToProto(
	textAffix: TextAffix
): ChromeTextHeaderFooterP | undefined {
	if (!textAffix) return undefined;
	return {
		leftText: textAffix.leftText,
		rightText: textAffix.rightText,
		centerText: textAffix.centerText,
		font: fontToProto(textAffix.font),
		fontSize: textAffix.fontSize ?? 12,
		dividerLineColor: textAffix.dividerLineColor ?? "#B1B1B1",
		drawDividerLine: textAffix.dividerLine ?? false,
	};
}

export function fontToProto(affixFonts?: AffixFonts): FontTypeP | undefined {
	if (!affixFonts) return {name: AffixFonts[AffixFonts.Arial].replace("_","-")};
	return {name: AffixFonts[affixFonts].replace("_","-")};
}

export function useMarginsToProto(
	useMargins?: UseMargins
): ChromeUseMarginsP | undefined {
	return {enumValue: useMargins};
}

export function paperSizeToProto(
	paperSize?: PaperSize
): ChromePdfPaperSizeP | undefined {
	if (!paperSize) return undefined;
	return {enumValue: paperSize};
}

function toMillimeters(paperSize: PaperSize): WidthHeight {
	switch (paperSize) {
		case PaperSize.Letter:
			return {width: 216, height: 279};
		case PaperSize.Legal:
			return {width: 216, height: 356};
		case PaperSize.A4:
			return {width: 210, height: 297};
		case PaperSize.CSheet:
			return {width: 432, height: 559};
		case PaperSize.DSheet:
			return {width: 559, height: 864};
		case PaperSize.ESheet:
			return {width: 864, height: 1118};
		case PaperSize.LetterSmall:
			return {width: 216, height: 279};
		case PaperSize.Tabloid:
			return {width: 279, height: 432};
		case PaperSize.Ledger:
			return {width: 432, height: 279};
		case PaperSize.Statement:
			return {width: 140, height: 216};
		case PaperSize.Executive:
			return {width: 184, height: 267};
		case PaperSize.A3:
			return {width: 297, height: 420};
		case PaperSize.A4Small:
			return {width: 210, height: 297};
		case PaperSize.A5:
			return {width: 148, height: 210};
		case PaperSize.B4:
			return {width: 250, height: 353};
		case PaperSize.B5:
			return {width: 176, height: 250};
		case PaperSize.Folio:
			return {width: 216, height: 330};
		case PaperSize.Quarto:
			return {width: 215, height: 275};
		case PaperSize.Standard10x14:
			return {width: 254, height: 356};
		case PaperSize.Standard11x17:
			return {width: 279, height: 432};
		case PaperSize.Note:
			return {width: 216, height: 279};
		case PaperSize.Number9Envelope:
			return {width: 98, height: 225};
		case PaperSize.Number10Envelope:
			return {width: 105, height: 241};
		case PaperSize.Number11Envelope:
			return {width: 114, height: 264};
		case PaperSize.Number12Envelope:
			return {width: 121, height: 279};
		case PaperSize.Number14Envelope:
			return {width: 127, height: 292};
		case PaperSize.DLEnvelope:
			return {width: 110, height: 220};
		case PaperSize.C5Envelope:
			return {width: 162, height: 229};
		case PaperSize.C3Envelope:
			return {width: 324, height: 458};
		case PaperSize.C4Envelope:
			return {width: 229, height: 324};
		case PaperSize.C65Envelope:
			return {width: 114, height: 229};
		case PaperSize.B4Envelope:
			return {width: 250, height: 353};
		case PaperSize.B5Envelope:
			return {width: 176, height: 250};
		case PaperSize.B6Envelope:
			return {width: 176, height: 125};
		case PaperSize.ItalyEnvelope:
			return {width: 110, height: 230};
		case PaperSize.MonarchEnvelope:
			return {width: 98, height: 191};
		case PaperSize.PersonalEnvelope:
			return {width: 92, height: 165};
		case PaperSize.USStandardFanfold:
			return {width: 378, height: 279};
		case PaperSize.GermanStandardFanfold:
			return {width: 216, height: 305};
		case PaperSize.GermanLegalFanfold:
			return {width: 216, height: 330};
		case PaperSize.IsoB4:
			return {width: 250, height: 353};
		case PaperSize.JapanesePostcard:
			return {width: 100, height: 148};
		case PaperSize.Standard9x11:
			return {width: 229, height: 279};
		case PaperSize.Standard10x11:
			return {width: 254, height: 279};
		case PaperSize.Standard15x11:
			return {width: 381, height: 279};
		case PaperSize.InviteEnvelope:
			return {width: 220, height: 220};
		case PaperSize.LetterExtra:
			return {width: 236, height: 305};
		case PaperSize.LegalExtra:
			return {width: 236, height: 381};
		case PaperSize.TabloidExtra:
			return {width: 297, height: 457};
		case PaperSize.A4Extra:
			return {width: 236, height: 322};
		case PaperSize.LetterTransverse:
			return {width: 210, height: 279};
		case PaperSize.A4Transverse:
			return {width: 210, height: 297};
		case PaperSize.LetterExtraTransverse:
			return {width: 236, height: 305};
		case PaperSize.APlus:
			return {width: 227, height: 356};
		case PaperSize.BPlus:
			return {width: 305, height: 487};
		case PaperSize.LetterPlus:
			return {width: 216, height: 322};
		case PaperSize.A4Plus:
			return {width: 210, height: 330};
		case PaperSize.A5Transverse:
			return {width: 148, height: 210};
		case PaperSize.B5Transverse:
			return {width: 182, height: 257};
		case PaperSize.A3Extra:
			return {width: 322, height: 445};
		case PaperSize.A5Extra:
			return {width: 174, height: 235};
		case PaperSize.B5Extra:
			return {width: 201, height: 276};
		case PaperSize.A2:
			return {width: 420, height: 594};
		case PaperSize.A3Transverse:
			return {width: 297, height: 420};
		case PaperSize.A3ExtraTransverse:
			return {width: 322, height: 445};
		case PaperSize.JapaneseDoublePostcard:
			return {width: 200, height: 148};
		case PaperSize.A6:
			return {width: 105, height: 148};
		case PaperSize.LetterRotated:
			return {width: 279, height: 216};
		case PaperSize.A3Rotated:
			return {width: 420, height: 297};
		case PaperSize.A4Rotated:
			return {width: 297, height: 210};
		case PaperSize.A5Rotated:
			return {width: 210, height: 148};
		case PaperSize.B4JisRotated:
			return {width: 364, height: 257};
		case PaperSize.B5JisRotated:
			return {width: 257, height: 182};
		case PaperSize.JapanesePostcardRotated:
			return {width: 148, height: 100};
		case PaperSize.JapaneseDoublePostcardRotated:
			return {width: 148, height: 200};
		case PaperSize.A6Rotated:
			return {width: 148, height: 105};
		case PaperSize.B6Jis:
			return {width: 128, height: 182};
		case PaperSize.B6JisRotated:
			return {width: 182, height: 128};
		case PaperSize.Standard12x11:
			return {width: 305, height: 279};
		case PaperSize.Prc16K:
			return {width: 146, height: 215};
		case PaperSize.Prc32K:
			return {width: 97, height: 151};
		case PaperSize.Prc32KBig:
			return {width: 97, height: 151};
		case PaperSize.PrcEnvelopeNumber1:
			return {width: 102, height: 165};
		case PaperSize.PrcEnvelopeNumber2:
			return {width: 102, height: 176};
		case PaperSize.PrcEnvelopeNumber3:
			return {width: 125, height: 176};
		case PaperSize.PrcEnvelopeNumber4:
			return {width: 110, height: 208};
		case PaperSize.PrcEnvelopeNumber5:
			return {width: 110, height: 220};
		case PaperSize.PrcEnvelopeNumber6:
			return {width: 120, height: 230};
		case PaperSize.PrcEnvelopeNumber7:
			return {width: 160, height: 230};
		case PaperSize.PrcEnvelopeNumber8:
			return {width: 120, height: 309};
		case PaperSize.PrcEnvelopeNumber9:
			return {width: 229, height: 324};
		case PaperSize.PrcEnvelopeNumber10:
			return {width: 324, height: 458};
		case PaperSize.Prc16KRotated:
			return {width: 215, height: 146};
		case PaperSize.Prc32KRotated:
			return {width: 151, height: 97};
		case PaperSize.Prc32KBigRotated:
			return {width: 151, height: 97};
		case PaperSize.PrcEnvelopeNumber1Rotated:
			return {width: 165, height: 102};
		case PaperSize.PrcEnvelopeNumber2Rotated:
			return {width: 176, height: 102};
		case PaperSize.PrcEnvelopeNumber3Rotated:
			return {width: 176, height: 125};
		case PaperSize.PrcEnvelopeNumber4Rotated:
			return {width: 208, height: 110};
		case PaperSize.PrcEnvelopeNumber5Rotated:
			return {width: 220, height: 110};
		case PaperSize.PrcEnvelopeNumber6Rotated:
			return {width: 230, height: 120};
		case PaperSize.PrcEnvelopeNumber7Rotated:
			return {width: 230, height: 160};
		case PaperSize.PrcEnvelopeNumber8Rotated:
			return {width: 309, height: 120};
		case PaperSize.PrcEnvelopeNumber9Rotated:
			return {width: 324, height: 229};
		case PaperSize.PrcEnvelopeNumber10Rotated:
			return {width: 458, height: 324};
		default:
			throw new Error("Unsupported paper size");
	}
}

export function pdfPaperSizeToProto(
	pdfPaperSize?: PdfPaperSize
): { paperSizeP: ChromePdfPaperSizeP; widthHeight?: WidthHeight } | undefined {
	if (!pdfPaperSize) return undefined;

	if (typeof pdfPaperSize === "object") {
		if ("width" in pdfPaperSize) {
			return {
				paperSizeP: {enumValue: 106},
				widthHeight: {
					width: pdfPaperSize.width,
					height: pdfPaperSize.height,
				},
			};
		}
	} else {
		const wh = toMillimeters(pdfPaperSize);
		return {
			paperSizeP: {enumValue: pdfPaperSize},
			widthHeight: {width: wh.width, height: wh.height},
		};
	}
}

export function imageBehaviorToProto(
	imageBehavior?: ImageBehavior
): ChromeImageBehaviorP | undefined {
	if (!imageBehavior) return undefined;
	return {enumValue: imageBehavior};
}

export function customPaperSizeToMm(
	customPaperSize: CustomPaperSize
): WidthHeight {
	switch (customPaperSize.unit) {
		case PaperSizeUnit.Centimeter:
			return {
				width: customPaperSize.width * 10,
				height: customPaperSize.height * 10,
			};
		case PaperSizeUnit.Inch:
			return {
				width: customPaperSize.width * 25.4,
				height: customPaperSize.height * 25.4,
			};
		case PaperSizeUnit.Millimeter:
			return {
				width: customPaperSize.width,
				height: customPaperSize.height,
			};
		case PaperSizeUnit.Points:
			return {
				width: customPaperSize.width * 0.352777778,
				height: customPaperSize.height * 0.352777778,
			};
	}
}

export type WidthHeight = { width: number; height: number };

function BaseStampOptionsToProto(
	id: string,
	pagesInfo: PageInfo[],
	defaultRenderDelay: number,
	password?: PdfPassword,
	options?: BaseStampOptions,
	pageSelection?: PdfPageSelection
): _ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP {
	const pi =
		PdfPageSelectionToIndexes(id, pagesInfo, pageSelection) ??
		Array.from({
			length: pagesInfo.length,
		}).map((value, index) => index);
	const pageP: PdfiumPageP[] = pi.map((pageIndex) => {
		// if (pagesInfo) {
		return {
			width: pagesInfo[pageIndex].millimeterWidth,
			height: pagesInfo[pageIndex].millimeterHeight,
			pageIndex: pageIndex,
			pageRotation: PageRotationToProto(
				pagesInfo[pageIndex].pageRotation
			),
			printWidth: pagesInfo[pageIndex].printerPointWidth,
			printHeight: pagesInfo[pageIndex].printerPointHeight,
		};
		// }
		// return { pageIndex: pageIndex };
	});

	return {
		document: {documentId: id},
		hyperlink: options?.hyperlink,
		horizontalAlignment: horizontalAlignmentToProto(
			options?.horizontalAlignment
		),
		verticalAlignment: verticalAlignmentToProto(options?.verticalAlignment),
		horizontalOffset: lengthToProto(options?.horizontalOffset),
		verticalOffset: lengthToProto(options?.verticalOffset),
		isStampBehindContent: options?.behindExistingContent ?? false,
		opacity: options?.opacity,
		rotation: options?.rotation,
		scale: options?.scale,
		targetPages: pageP ?? [],
		ownerPassword: password?.ownerPassword,
		userPassword: password?.userPassword,
		renderDelay: options?.renderDelay ?? defaultRenderDelay,
		timeout: options?.timeout ?? 60,
		maxHeight: lengthToProto(options?.maxHeight),
		minHeight: lengthToProto(options?.minHeight),
		maxWidth: lengthToProto(options?.maxWidth),
		minWidth: lengthToProto(options?.minWidth),
	};
}

export function HtmlStampOptionsToProto(
	id: string,
	pagesInfo: PageInfo[],
	password?: PdfPassword,
	options?: HtmlStampOptions,
	pageSelection?: PdfPageSelection
): _ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP {
	const base = BaseStampOptionsToProto(
		id,
		pagesInfo,
		100,
		password,
		options,
		pageSelection
	);
	base.htmlStamper = {
		//baseUrl: options?.baseUrl,  //not supported
		cssMediaType: cssMediaTypeToProto(options?.cssMediaType),
	};
	return base;
}

export function TextStampOptionsToProto(
	id: string,
	pagesInfo: PageInfo[],
	password?: PdfPassword,
	options?: TextStampOptions,
	pageSelection?: PdfPageSelection
): _ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP {
	const base = BaseStampOptionsToProto(
		id,
		pagesInfo,
		0,
		password,
		options,
		pageSelection
	);
	base.textStamper = {
		textColor: options?.textColor,
		fontSize: options?.fontSize,
		backgroundColor: options?.backgroundColor,
		fontFamily: options?.fontFamily,
		isBold: options?.isBold,
		isItalic: options?.isItalic,
		isStrikethrough: options?.isStrikethrough,
		isUnderline: options?.isUnderline,
		useGoogleFont: options?.useGoogleFont,
	};
	return base;
}

export function ImageStampOptionsToProto(
	id: string,
	pagesInfo: PageInfo[],
	password?: PdfPassword,
	options?: ImageStampOptions,
	pageSelection?: PdfPageSelection
): _ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP {
	const base = BaseStampOptionsToProto(
		id,
		pagesInfo,
		0,
		password,
		options,
		pageSelection
	);
	base.imageStamper = {};
	return base;
}

export function BarcodeStampOptionsToProto(
	id: string,
	pagesInfo: PageInfo[],
	password?: PdfPassword,
	options?: BarcodeStampOptions,
	pageSelection?: PdfPageSelection
): _ironpdfengineproto_ChromeApplyStampRequestStreamP_InfoP {
	const base = BaseStampOptionsToProto(
		id,
		pagesInfo,
		0,
		password,
		options,
		pageSelection
	);
	base.barcodeStamper = {
		widthPx: options?.widthPx ?? 250,
		heightPx: options?.heightPx ?? 250,
		barcodeType: barcodeTypeToProto(
			options?.barcodeType ?? BarcodeType.qrCode
		),
	};
	return base;
}

export function lengthToProto(length?: Length): LengthP | undefined {
	if (!length) return undefined;
	return {
		value: length.value,
		unit: measurementUnitToProto(length.unit),
	};
}

export function measurementUnitToProto(
	measurementUnit?: MeasurementUnit
): MeasurementUnitP | undefined {
	if (!measurementUnit) return undefined;
	return {
		enumValue: measurementUnit,
	};
}

export function horizontalAlignmentToProto(
	horizontalAlignment?: HorizontalAlignment
): HorizontalAlignmentP | undefined {
	if (!horizontalAlignment) return undefined;
	return {
		enumValue: horizontalAlignment,
	};
}

export function verticalAlignmentToProto(
	verticalAlignment?: VerticalAlignment
): VerticalAlignmentP | undefined {
	if (!verticalAlignment) return undefined;
	return {
		enumValue: verticalAlignment,
	};
}

export function cssMediaTypeToProto(
	cssMediaType?: CssMediaType
): ChromePdfCssMediaTypeP | undefined {
	if (!cssMediaType) return undefined;
	return {
		enumValue: cssMediaType,
	};
}

export function barcodeTypeToProto(
	barcodeType?: BarcodeType
): ChromeBarcodeEncodingP | undefined {
	if (!barcodeType) return undefined;
	return {
		enumValue: barcodeType,
	};
}
