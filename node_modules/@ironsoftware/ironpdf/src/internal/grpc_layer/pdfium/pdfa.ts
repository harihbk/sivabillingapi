import {ServiceError} from "@grpc/grpc-js";
import {IronPdfServiceClient} from "../../generated_proto/ironpdfengineproto/IronPdfService";
import {Access} from "../../access";
import {EmptyResultP__Output} from "../../generated_proto/ironpdfengineproto/EmptyResultP";
import {
	chunkBuffer,
	handleEmptyResultP__Output,
	handlePdfDocumentResultP__Output,
	handleRemoteException
} from "../util";
import fs from "fs";
import {PdfDocumentResultP__Output} from "../../generated_proto/ironpdfengineproto/PdfDocumentResultP";

export async function toPdfA(id: string, customICCFilePath?: string): Promise<void> {
	const client: IronPdfServiceClient = await Access.ensureConnection();
	return new Promise(
		(resolve: () => void, reject: (errorMsg: string) => void) => {
			const stream = client.Pdfium_ConvertToPdfA(
				(
					err: ServiceError | null,
					value: PdfDocumentResultP__Output | undefined
				) => {
					if (err) {
						reject(`${err.name}/n${err.message}`);
					} else if (value) {
						if (value?.exception) {
							handleRemoteException(value.exception, reject);
						}else{
							resolve()
						}
					}
				}
			);

			stream.write({info: {document: {documentId: id}}})

			if (customICCFilePath) {
				chunkBuffer(fs.readFileSync(customICCFilePath)).forEach((chunk) => {
					stream.write({
						iccBytesChunk: chunk
					});
				});
			}
			stream.end()
		}
	);
}


export async function toPdfUA(id: string): Promise<void> {
	const client: IronPdfServiceClient = await Access.ensureConnection();
	return new Promise(
		(resolve: () => void, reject: (errorMsg: string) => void) => {
			client.Pdfium_ConvertToPdfUA(
				{
					document: { documentId: id },
				},
				(
					err: ServiceError | null,
					value: EmptyResultP__Output | undefined
				) => {
					if (err) {
						reject(`${err.name}/n${err.message}`);
					} else if (value) {
						handleEmptyResultP__Output(value, reject);
						resolve();
					}
				}
			);
		}
	);
}
