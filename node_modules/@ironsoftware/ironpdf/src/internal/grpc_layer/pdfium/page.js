"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.duplicate = exports.handlePdfiumRemovePagesResultP__Output = exports.removePage = exports.insertPdf = exports.resizePage = exports.setPageRotation = exports.getPageInfo = void 0;
const access_1 = require("../../access");
const util_1 = require("../util");
const converter_1 = require("./converter");
const converter_2 = require("../chrome/converter");
function getPageInfo(id) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            client.pdfiumPageGetPages({ document: { documentId: id } }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    resolve(handlePdfiumGetPagesResultP__Output(value, reject));
                }
            });
        });
    });
}
exports.getPageInfo = getPageInfo;
function setPageRotation(id, pageRotation, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, options === null || options === void 0 ? void 0 : options.pdfPageSelection);
        return new Promise((resolve, reject) => {
            client.pdfiumPageSetPagesRotation({
                document: { documentId: id },
                pageIndexes: pi,
                pageRotation: (0, converter_1.PageRotationToProto)(pageRotation),
            }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handleEmptyResultP__Output)(value, reject);
                    resolve();
                }
            });
        });
    });
}
exports.setPageRotation = setPageRotation;
function resizePage(id, pdfPaperSize, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const paperSizeSetting = (0, converter_2.pdfPaperSizeToProto)(pdfPaperSize);
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, options === null || options === void 0 ? void 0 : options.pdfPageSelection);
        const promises = pi.map((pageIndex) => {
            return new Promise((resolve, reject) => {
                var _a, _b;
                const req = {
                    document: { documentId: id },
                    pageHeight: (_a = paperSizeSetting === null || paperSizeSetting === void 0 ? void 0 : paperSizeSetting.widthHeight) === null || _a === void 0 ? void 0 : _a.height,
                    pageWidth: (_b = paperSizeSetting === null || paperSizeSetting === void 0 ? void 0 : paperSizeSetting.widthHeight) === null || _b === void 0 ? void 0 : _b.width,
                    pageIndex: pageIndex
                };
                client.pdfiumPageResizePage(req, (err, value) => {
                    if (err) {
                        reject(`${err.name}/n${err.message}`);
                    }
                    else if (value) {
                        (0, util_1.handleEmptyResultP__Output)(value, reject);
                        resolve();
                    }
                });
            });
        });
        yield Promise.all(promises);
        return;
    });
}
exports.resizePage = resizePage;
function handlePdfiumGetPagesResultP__Output(proto, reject) {
    var _a, _b;
    if (proto) {
        if (proto.exception) {
            (0, util_1.handleRemoteException)(proto.exception, reject);
        }
        if (proto.result) {
            return ((_b = (_a = proto.result.pages) === null || _a === void 0 ? void 0 : _a.map((value) => (0, converter_1.PageInfoFromProto)(value))) !== null && _b !== void 0 ? _b : []);
        }
    }
    throw new Error("Error empty message");
}
function insertPdf(mainDocumentId, anotherDocumentId, insertionIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            client.pdfiumPageInsertPdf({
                mainDocument: { documentId: mainDocumentId },
                insertedDocument: { documentId: anotherDocumentId },
                insertionIndex: insertionIndex,
            }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handleEmptyResultP__Output)(value, reject);
                    resolve();
                }
            });
        });
    });
}
exports.insertPdf = insertPdf;
function removePage(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, options === null || options === void 0 ? void 0 : options.PdfPageSelection);
        return new Promise((resolve, reject) => {
            client.pdfiumPageRemovePages({
                document: { documentId: id },
                pageIndexes: pi,
            }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    const remaining = handlePdfiumRemovePagesResultP__Output(value, reject);
                    //ignore remaining
                    resolve();
                }
            });
        });
    });
}
exports.removePage = removePage;
function handlePdfiumRemovePagesResultP__Output(proto, reject) {
    if (proto) {
        if (proto.exception) {
            (0, util_1.handleRemoteException)(proto.exception, reject);
        }
        if (proto.result) {
            return proto.result;
        }
    }
    throw new Error("Error empty message");
}
exports.handlePdfiumRemovePagesResultP__Output = handlePdfiumRemovePagesResultP__Output;
function duplicate(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, options === null || options === void 0 ? void 0 : options.PdfPageSelection);
        return new Promise((resolve, reject) => {
            client.pdfiumPageCopyPages({
                document: { documentId: id },
                pageIndexes: pi,
            }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
        });
    });
}
exports.duplicate = duplicate;
//# sourceMappingURL=page.js.map