import { PdfPageSelection } from "../../../public/types";
import { HtmlAffix, TextAffix } from "../../../public/affix";
import { IronPdfServiceClient } from "../../generated_proto/ironpdfengineproto/IronPdfService";
import { Access } from "../../access";
import {
	ChromePdfRenderOptions,
	defaultChromePdfRenderOptions,
} from "../../../public/render";
import {
	AsyncPdfPageSelectionToIndexes,
	handleEmptyResultP__Output,
	PdfPageSelectionToIndexes,
} from "../util";
import { chromePdfRenderOptionsToProto } from "../chrome/converter";
import { getPageInfo } from "./page";

export async function addHtmlAffix(
	id: string,
	pdfPageSelection: PdfPageSelection,
	htmlAffix: HtmlAffix,
	isHeader: boolean
): Promise<void> {
	const client: IronPdfServiceClient = await Access.ensureConnection();
	const chromePdfRenderOptions = defaultChromePdfRenderOptions();

	if (isHeader) {
		chromePdfRenderOptions.htmlHeader = htmlAffix;
	} else {
		chromePdfRenderOptions.htmlFooter = htmlAffix;
	}
	return fireHtmlRequest(
		client,
		id,
		pdfPageSelection,
		chromePdfRenderOptions
	);
}

export async function addTextAffix(
	id: string,
	pdfPageSelection: PdfPageSelection,
	textAffix: TextAffix,
	isHeader: boolean
): Promise<void> {
	const client: IronPdfServiceClient = await Access.ensureConnection();
	const chromePdfRenderOptions = defaultChromePdfRenderOptions();

	if (isHeader) {
		chromePdfRenderOptions.textHeader = textAffix;
	} else {
		chromePdfRenderOptions.textFooter = textAffix;
	}
	return fireTextRequest(
		client,
		id,
		pdfPageSelection,
		chromePdfRenderOptions
	);
}

async function fireTextRequest(
	client: IronPdfServiceClient,
	id: string,
	pdfPageSelection: PdfPageSelection,
	chromePdfRenderOptions: ChromePdfRenderOptions
): Promise<void> {
	const pi = await AsyncPdfPageSelectionToIndexes(id, pdfPageSelection);

	return new Promise(
		(resolve: () => void, reject: (errorMsg: string) => void) => {
			client.pdfiumHeaderFooterAddTextHeaderFooter(
				{
					document: { documentId: id },
					pageIndexes: pi,
					options: chromePdfRenderOptionsToProto(
						chromePdfRenderOptions
					),
					// pdfTitle:htmlAffix
					// htmlTitle:
					// url:
				},
				(err, value) => {
					if (err) {
						reject(`${err.name}/n${err.message}`);
					} else if (value) {
						handleEmptyResultP__Output(value, reject);
						resolve();
					}
				}
			);
		}
	);
}

async function fireHtmlRequest(
	client: IronPdfServiceClient,
	id: string,
	pdfPageSelection: PdfPageSelection,
	chromePdfRenderOptions: ChromePdfRenderOptions
): Promise<void> {
	const pi = await AsyncPdfPageSelectionToIndexes(id, pdfPageSelection);
	return new Promise(
		(resolve: () => void, reject: (errorMsg: string) => void) => {
			client.chromeHeaderFooterAddHtmlHeaderFooter(
				{
					document: { documentId: id },
					pageIndexes: pi,
					options: chromePdfRenderOptionsToProto(
						chromePdfRenderOptions
					),
					// pdfTitle:htmlAffix
					// htmlTitle:
					// url:
				},
				(err, value) => {
					if (err) {
						reject(`${err.name}/n${err.message}`);
					} else if (value) {
						handleEmptyResultP__Output(value, reject);
						resolve();
					}
				}
			);
		}
	);
}
