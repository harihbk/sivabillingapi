"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAllText = exports.replaceText = void 0;
const access_1 = require("../../access");
const util_1 = require("../util");
function replaceText(id, currentText, newText, destPageIndices) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, destPageIndices);
        return new Promise((resolve, reject) => {
            pi.forEach((pageIndex) => {
                client.pdfiumTextReplaceText({
                    document: { documentId: id },
                    currentText: currentText,
                    newText: newText,
                    pageIndex: pageIndex,
                }, (err, value) => {
                    if (err) {
                        reject(`${err.name}/n${err.message}`);
                    }
                    else if (value) {
                        (0, util_1.handleEmptyResultP__Output)(value, reject);
                        resolve();
                    }
                });
            });
        });
    });
}
exports.replaceText = replaceText;
function extractAllText(id, destPageIndices) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        const pi = yield (0, util_1.AsyncPdfPageSelectionToIndexes)(id, destPageIndices);
        return new Promise((resolve, reject) => {
            client.pdfiumTextExtractAllText({
                document: { documentId: id },
                pageIndexes: pi,
            }, (err, value) => {
                var _a;
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    if (value === null || value === void 0 ? void 0 : value.exception) {
                        (0, util_1.handleRemoteException)(value.exception, reject);
                    }
                    resolve((_a = value.result) !== null && _a !== void 0 ? _a : "");
                }
            });
        });
    });
}
exports.extractAllText = extractAllText;
//# sourceMappingURL=text.js.map