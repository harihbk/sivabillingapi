"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.disposePdf = exports.getBinaryData = exports.openPdfFileBuffer = void 0;
const access_1 = require("../../access");
const util_1 = require("../util");
const types_1 = require("../../../public/types");
function openPdfFileBuffer(buffer, option) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            var _a;
            const stream = client.Pdfium_FromBytes((err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    (0, util_1.handlePdfDocumentResultP__Output)(value, resolve, reject);
                }
            });
            stream.write({
                info: {
                    ownerPassword: option === null || option === void 0 ? void 0 : option.ownerPassword,
                    userPassword: option === null || option === void 0 ? void 0 : option.userPassword,
                    trackChanges: (_a = option === null || option === void 0 ? void 0 : option.trackChanges) !== null && _a !== void 0 ? _a : types_1.ChangeTrackingModes.AutoChangeTracking
                },
            });
            (0, util_1.chunkBuffer)(buffer).forEach((chunk) => {
                stream.write({ pdfBytesChunk: chunk });
            });
            stream.end();
        });
    });
}
exports.openPdfFileBuffer = openPdfFileBuffer;
function getBinaryData(pdfDocumentId, saveOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            const stream = client.Pdfium_GetBinaryData();
            //response handler
            const buffers = [];
            stream.on("data", (data) => {
                if (data.exception) {
                    reject(`${data.exception.message}/n${data.exception.remoteStackTrace}`);
                }
                else if (data.resultChunk) {
                    buffers.push(data.resultChunk);
                }
            });
            stream.on("end", () => {
                resolve(Buffer.concat(buffers));
            });
            //sent request
            //info
            stream.write({
                info: {
                    document: { documentId: pdfDocumentId },
                    isWatermarked: false,
                    isIncremental: saveOptions === null || saveOptions === void 0 ? void 0 : saveOptions.incremental,
                },
            });
            //not working for now
            // // signatures
            // const collection = saveOptions?.digitalSignatures?.map(
            // 	(digitalSignature, signatureIndex) => {
            // 		const pdfiumPdfSignatureP: PdfiumPdfSignatureP = {
            // 			index: signatureIndex,
            // 			password: digitalSignature.certificatePassword,
            // 			timestampUrl: digitalSignature.timeStampUrl,
            // 		};
            // 		return pdfiumPdfSignatureP;
            // 	}
            // );
            // stream.write({ signatures: { signature: collection } });
            // //rawSignaturesChunk
            // saveOptions?.digitalSignatures?.forEach(
            // 	(digitalSignature, signatureIndex) => {
            // 		const buf = digitalSignature.certificatePath
            // 			? fs.readFileSync(digitalSignature.certificatePath)
            // 			: digitalSignature.certificateBuffer;
            //
            // 		if (buf) {
            // 			chunkBuffer(buf).forEach((chunk) => {
            // 				const pdfiumRawSignatureChunkWithIndexP: PdfiumRawSignatureChunkWithIndexP =
            // 					{
            // 						rawSignatureChunk: chunk,
            // 						signatureIndex,
            // 					};
            // 				stream.write({
            // 					rawSignaturesChunk:
            // 						pdfiumRawSignatureChunkWithIndexP,
            // 				});
            // 			});
            // 		}
            // 	}
            // );
            //request finished
            stream.end();
        });
    });
}
exports.getBinaryData = getBinaryData;
function disposePdf(pdfDocumentId) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield access_1.Access.ensureConnection();
        return new Promise((resolve, reject) => {
            client.pdfiumDispose({ documentId: pdfDocumentId }, (err, value) => {
                if (err) {
                    reject(`${err.name}/n${err.message}`);
                }
                else if (value) {
                    //ignore result
                    resolve();
                }
            });
        });
    });
}
exports.disposePdf = disposePdf;
//# sourceMappingURL=io.js.map