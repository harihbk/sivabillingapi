import {
	ChromePdfRenderOptions,
	ImageBuffer,
	ImageFilePath,
	ImageToPdfOptions,
	PdfInput,
} from "./types";
import { PdfDocument } from "./pdfDocument";

/**
 * A utility class to create a new {@link PdfDocument} object
 */
export class PdfGenerator {
	/**
	 * Creates a PDF file from a Html string, and returns it as an {@link PdfDocument} object which can be edited and saved to disk or served on a website.
	 * @param htmlStringOrHtmlFilePath The Html to be rendered as a PDF.
	 * @param options including {@link ChromePdfRenderOptions}
	 */
	public static async htmlToPdf(
		htmlStringOrHtmlFilePath: string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default undefined
			 */
			renderOptions?: ChromePdfRenderOptions;
		}
	): Promise<PdfDocument> {
		return PdfDocument.fromHtml(htmlStringOrHtmlFilePath, options);
	}
	/**
	 * Create a PdfDocument from an Url
	 * @param url A website Url
	 * @param options including {@link ChromePdfRenderOptions}
	 */
	public static async urlToPdf(
		url: URL | string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default undefined
			 */
			renderOptions?: ChromePdfRenderOptions;
		}
	): Promise<PdfDocument> {
		return PdfDocument.fromUrl(url, options);
	}

	/**
	 * Creates a PDF file from a local Zip file, and returns it as a {@link PdfDocument}.
	 * IronPDF is a W3C standards compliant HTML rendering based on Google's Chromium browser.
	 * If your output PDF does not look as expected:
	 *
	 * - Validate your HTML file using  https://validator.w3.org/ &amp; CSS https://jigsaw.w3.org/css-validator/
	 *
	 * - To debug HTML, view the file in Chrome web browser's print preview which will work almost exactly as IronPDF.
	 *
	 * - Read our detailed documentation on pixel perfect HTML to PDF: https://ironpdf.com/tutorials/pixel-perfect-html-to-pdf/
	 *
	 * @param zipFilePath Path to a Zip to be rendered as a PDF.
	 * @param options including {@link ChromePdfRenderOptions} and `mainHtmlFile` a main .html file default: `index.html`
	 */
	public static async htmlZipFileToPdf(
		zipFilePath: string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default undefined
			 */
			renderOptions?: ChromePdfRenderOptions;
			mainHtmlFile?: string;
		}
	): Promise<PdfDocument> {
		return PdfDocument.fromZip(zipFilePath, options);
	}

	/**
	 *  Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image
	 *  dimensions. The default PaperSize is A4. You can set it via ImageToPdfConverter.PaperSize.
	 *  Note: Imaging.ImageBehavior.CropPage will set PaperSize equal to ImageSize.
	 * @param images The image file path name(s) or {@link ImageBuffer} object(s)
	 * @param options including {@link ImageToPdfOptions}
	 */
	public static async imageToPdf(
		images: ImageFilePath | ImageFilePath[] | ImageBuffer | ImageBuffer[],
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default undefined
			 */
			imageToPdfOptions?: ImageToPdfOptions;
		}
	): Promise<PdfDocument> {
		return PdfDocument.fromImage(images, options);
	}

	/**
	 * Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document.
	 * If the PDF contains form fields the form field in the resulting PDF's name will be appended with '_{index}' e.g. 'Name' will be 'Name_0'
	 * @param pdfs array of PDF
	 */
	public static async mergePdf(pdfs: PdfInput[]): Promise<PdfDocument> {
		return PdfDocument.mergePdf(pdfs);
	}
}
