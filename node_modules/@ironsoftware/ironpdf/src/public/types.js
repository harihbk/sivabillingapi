"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeTrackingModes = exports.ChromeGpuModes = exports.UseMargins = exports.MeasurementUnit = exports.FitToPaperModes = exports.CssMediaType = exports.VerticalAlignment = exports.HorizontalAlignment = void 0;
__exportStar(require("./affix"), exports);
__exportStar(require("./image"), exports);
__exportStar(require("./ironpdfglobalconfig"), exports);
__exportStar(require("./page"), exports);
__exportStar(require("./paper"), exports);
__exportStar(require("./signature"), exports);
__exportStar(require("./stamp"), exports);
__exportStar(require("./render"), exports);
__exportStar(require("./security"), exports);
/**
 * Horizontal layout alignment relative to the PDF page.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = 1] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = 2] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Vertical layout alignment relative to the PDF page.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = 1] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Defines which style-sheet should be rendered.   'Print' or 'Screen'.  This matches the CSS3 Media
 * Queries standard.
 */
var CssMediaType;
(function (CssMediaType) {
    /**
     * Renders as expected for a web browser.
     */
    CssMediaType[CssMediaType["Print"] = 0] = "Print";
    /**
     * Ignores 'Print' styles and includes additional 'Screen' styles where available.
     */
    CssMediaType[CssMediaType["Screen"] = 1] = "Screen";
})(CssMediaType = exports.CssMediaType || (exports.CssMediaType = {}));
/**
 * Behaviors when fitting HTML content to a physical paper size
 * Can affect zoom level and css layout
 */
var FitToPaperModes;
(function (FitToPaperModes) {
    /**
     * Do nothing.
     * Default Chrome PDF printing behavior. Uses {@link ChromePdfRenderOptions.zoom} to specify zoom level.
     * {@link ChromePdfRenderOptions.viewPortWidth} has no effect.
     *
     * Instead, Chrome will automatically set the view port based on {@link ChromePdfRenderOptions.paperSize}.
     * Use {@link ChromePdfRenderOptions.cssMediaType} to specify CSS media style.
     *
     * Useful when using {@link ChromePdfRenderOptions.cssMediaType.Print} CSS media style or printing documents to match the Chrome browser print preview.
     */
    FitToPaperModes[FitToPaperModes["Default"] = 0] = "Default";
    /**
     * Fit an exact number of pixels onto each PDF page.
     * Uses {@link ChromePdfRenderOptions.viewPortWidth} to specify the pixel width to fit on each PDF page.
     * {@link ChromePdfRenderOptions.zoom} has no effect. Instead, IronPdf will calculate the zoom level based on
     * {@link ChromePdfRenderOptions.viewPortWidth} and {@link ChromePdfRenderOptions.paperSize}
     *
     * Useful when an optimal pixel width is known or printing documents to match a Chrome browser window display
     */
    FitToPaperModes[FitToPaperModes["FitToWidth"] = 1] = "FitToWidth";
    /**
     * Measures minimum HTML content width after it is rendered by the browser and calculates {@link ChromePdfRenderOptions.zoom}
     * based on the width of the content.
     * {@link ChromePdfRenderOptions.zoom} and {@link ChromePdfRenderOptions.viewPortWidth} have no effect and are calculated automatically by IronPdf.
     *
     * Useful when fitting a wide content or content of unknown width onto a PDF page
     */
    FitToPaperModes[FitToPaperModes["FitToHeight"] = 2] = "FitToHeight";
    /**
     * Measures minimum HTML content width after it is rendered by the browser using the smallest view port possible, and calculates
     * {@link ChromePdfRenderOptions.zoom} based on the width of the content.
     * Use {@link ChromePdfRenderOptions.viewPortWidth} to specify the minimum number of pixels to be fit on each PDF page.
     * {@link ChromePdfRenderOptions.zoom} has no effect and is calculated automatically by IronPdf.
     *
     * Useful when fitting smaller content onto a wide page
     */
    FitToPaperModes[FitToPaperModes["FitToPage"] = 3] = "FitToPage";
    /**
     *  Creates a single page PDF which will force its entire content's width and height to fit into one page.
     *  Can be used for a consumer bill or receipt.
     *
     *  Useful when printing bill or receipt
     */
    FitToPaperModes[FitToPaperModes["ContinuousFeed"] = 4] = "ContinuousFeed";
})(FitToPaperModes = exports.FitToPaperModes || (exports.FitToPaperModes = {}));
/**
 * The unit of measurement used for positioning and sizing.
 */
var MeasurementUnit;
(function (MeasurementUnit) {
    MeasurementUnit[MeasurementUnit["Percentage"] = 0] = "Percentage";
    MeasurementUnit[MeasurementUnit["Millimeter"] = 1] = "Millimeter";
    MeasurementUnit[MeasurementUnit["Inch"] = 2] = "Inch";
    MeasurementUnit[MeasurementUnit["Centimeter"] = 3] = "Centimeter";
    MeasurementUnit[MeasurementUnit["Pixel"] = 4] = "Pixel";
    MeasurementUnit[MeasurementUnit["Points"] = 5] = "Points";
})(MeasurementUnit = exports.MeasurementUnit || (exports.MeasurementUnit = {}));
/**
 * A flag that only apply the specific side of margin
 */
var UseMargins;
(function (UseMargins) {
    UseMargins[UseMargins["None"] = 0] = "None";
    UseMargins[UseMargins["Top"] = 1] = "Top";
    UseMargins[UseMargins["Bottom"] = 2] = "Bottom";
    UseMargins[UseMargins["Left"] = 4] = "Left";
    UseMargins[UseMargins["Right"] = 8] = "Right";
    UseMargins[UseMargins["TopAndBottom"] = 3] = "TopAndBottom";
    UseMargins[UseMargins["LeftAndRight"] = 12] = "LeftAndRight";
    UseMargins[UseMargins["All"] = 15] = "All";
})(UseMargins = exports.UseMargins || (exports.UseMargins = {}));
/**
 * Union type representing different Chrome GPU modes.
 * - Disabled": Disable GPU hardware utilization
 * - Software": Enable software acceleration
 * - Hardware": Enable hardware acceleration
 * - HardwareFull": Enable hardware acceleration with Vulkan features
 */
var ChromeGpuModes;
(function (ChromeGpuModes) {
    ChromeGpuModes["Disabled"] = "Disabled";
    ChromeGpuModes["Software"] = "Software";
    ChromeGpuModes["Hardware"] = "Hardware";
    ChromeGpuModes["HardwareFull"] = "HardwareFull";
})(ChromeGpuModes = exports.ChromeGpuModes || (exports.ChromeGpuModes = {}));
var ChangeTrackingModes;
(function (ChangeTrackingModes) {
    ChangeTrackingModes[ChangeTrackingModes["AutoChangeTracking"] = 0] = "AutoChangeTracking";
    ChangeTrackingModes[ChangeTrackingModes["EnableChangeTracking"] = 1] = "EnableChangeTracking";
    ChangeTrackingModes[ChangeTrackingModes["DisableChangeTracking"] = 2] = "DisableChangeTracking";
})(ChangeTrackingModes = exports.ChangeTrackingModes || (exports.ChangeTrackingModes = {}));
//# sourceMappingURL=types.js.map