"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfDocument = void 0;
const buffer_1 = require("buffer");
const types_1 = require("./types");
const typeSchema_1 = require("../internal/zod/typeSchema");
const zod_1 = require("zod");
const securitySchema_1 = require("../internal/zod/securitySchema");
const pdfDocumentSchema_1 = require("../internal/zod/pdfDocumentSchema");
const stampSchema_1 = require("../internal/zod/stampSchema");
const affixSchema_1 = require("../internal/zod/affixSchema");
const signatureSchema_1 = require("../internal/zod/signatureSchema");
const imageSchema_1 = require("../internal/zod/imageSchema");
const paperSchema_1 = require("../internal/zod/paperSchema");
const pageSchema_1 = require("../internal/zod/pageSchema");
const renderSchema_1 = require("../internal/zod/renderSchema");
const util_1 = require("../internal/grpc_layer/util");
const fs_1 = __importDefault(require("fs"));
const render_1 = require("../internal/grpc_layer/chrome/render");
const io_1 = require("../internal/grpc_layer/pdfium/io");
const access_1 = require("../internal/access");
const image_1 = require("../internal/grpc_layer/chrome/image");
const compress_1 = require("../internal/grpc_layer/pdfium/compress");
const page_1 = require("../internal/grpc_layer/pdfium/page");
const image_2 = require("../internal/grpc_layer/pdfium/image");
const jimp_1 = __importDefault(require("jimp"));
const text_1 = require("../internal/grpc_layer/pdfium/text");
const pdfa_1 = require("../internal/grpc_layer/pdfium/pdfa");
const metadata_1 = require("../internal/grpc_layer/pdfium/metadata");
const signing_1 = require("../internal/grpc_layer/pdfium/signing");
const headerFooter_1 = require("../internal/grpc_layer/pdfium/headerFooter");
const stamp_1 = require("../internal/grpc_layer/chrome/stamp");
const BackgroundForeground_1 = require("../internal/grpc_layer/pdfium/BackgroundForeground");
const security_1 = require("../internal/grpc_layer/pdfium/security");
/**
 * Represents a PDF document. Allows: loading, editing, manipulating, merging, signing printing and saving PDFs.
 *
 * @remark Make sure that you call {@link PdfDocument.close} or {@link cleanUp} to free the memory, when you stop using the PdfDocument object.
 */
class PdfDocument {
    //#region io
    /**
     * Open or Create a PdfDocument from a {@link PdfInput}
     * @param pdfInput {@link PdfInput}
     * @param options including {@link PdfPassword} {@link ChromePdfRenderOptions} {@link HttpLoginCredentials} mainHtmlFile
     */
    static open(pdfInput, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.pdfInputSchema, zod_1.z.object({
                password: typeSchema_1.pdfPasswordSchema.optional(),
                renderOptions: renderSchema_1.chromePdfRenderOptionsSchema.optional(),
                httpLoginCredentials: renderSchema_1.httpLoginCredentialsSchema.optional(),
                mainHtmlFile: typeSchema_1.stringSchema.optional(),
                trackChanges: typeSchema_1.changeTrackingModesSchema.optional(),
            }).optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_open.bind(this))(pdfInput, options);
        });
    }
    /**
     * Open a PdfDocument from .pdf file
     * @param pdfFilePath A path to .pdf file
     * @param Optionally track changes to the document (for use with incremental saves)
     */
    static fromFile(pdfFilePath, trackChanges) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.pdfFilePathSchema, typeSchema_1.changeTrackingModesSchema.optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_fromFile.bind(this))(pdfFilePath, trackChanges);
        });
    }
    /**
     * Create a PdfDocument from an Url
     * @param url A website Url
     * @param options including {@link ChromePdfRenderOptions}
     */
    static fromUrl(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.union([typeSchema_1.urlSchema, typeSchema_1.stringSchema]), zod_1.z.object({
                renderOptions: renderSchema_1.chromePdfRenderOptionsSchema.optional(),
            }).optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_fromUrl.bind(this))(url, options);
        });
    }
    /**
     * Creates a PDF file from a local Zip file, and returns it as a {@link PdfDocument}.
     * IronPDF is a W3C standards compliant HTML rendering based on Google's Chromium browser.
     * If your output PDF does not look as expected:
     *
     * - Validate your HTML file using  https://validator.w3.org/ &amp; CSS https://jigsaw.w3.org/css-validator/
     *
     * - To debug HTML, view the file in Chrome web browser's print preview which will work almost exactly as IronPDF.
     *
     * - Read our detailed documentation on pixel perfect HTML to PDF: https://ironpdf.com/tutorials/pixel-perfect-html-to-pdf/
     *
     * @param zipFilePath Path to a Zip to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions} and `mainHtmlFile` a main .html file default: `index.html`
     */
    static fromZip(zipFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.stringSchema, zod_1.z.object({
                renderOptions: renderSchema_1.chromePdfRenderOptionsSchema.optional(),
                mainHtmlFile: typeSchema_1.stringSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_fromZip.bind(this))(zipFilePath, options);
        });
    }
    /**
     * Creates a PDF file from a Html string, and returns it as an {@link PdfDocument} object which can be edited and saved to disk or served on a website.
     * @param htmlStringOrHtmlFilePath The Html to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions}
     */
    static fromHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.stringSchema, zod_1.z.object({
                renderOptions: renderSchema_1.chromePdfRenderOptionsSchema.optional(),
            }).optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_fromHtml.bind(this))(htmlStringOrHtmlFilePath, options);
        });
    }
    /**
     *  Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image
     *  dimensions. The default PaperSize is A4. You can set it via ImageToPdfConverter.PaperSize.
     *  Note: Imaging.ImageBehavior.CropPage will set PaperSize equal to ImageSize.
     * @param images The image file path name(s) or {@link ImageBuffer} object(s)
     * @param options including {@link ImageToPdfOptions}
     */
    static fromImage(images, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.union([typeSchema_1.imageFilePathSchema, zod_1.z.array(typeSchema_1.imageFilePathSchema), typeSchema_1.imageBufferSchema, zod_1.z.array(typeSchema_1.imageBufferSchema)]), zod_1.z.object({
                imageToPdfOptions: imageSchema_1.imageToPdfOptionsSchema.optional(),
            }).optional())
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_fromImage.bind(this))(images, options);
        });
    }
    /**
     * Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document.
     * If the PDF contains form fields the form field in the resulting PDF's name will be appended with '_{index}' e.g. 'Name' will be 'Name_0'
     * @param pdfs array of PDF
     */
    static mergePdf(pdfs) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.array(typeSchema_1.pdfInputSchema))
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_mergePdf.bind(this))(pdfs);
        });
    }
    /**
     * Saves the PdfDocument to a file.
     * @param filePath Target file path
     * @param saveOptions see {@link SaveOptions}
     */
    saveAs(filePath, saveOptions) {
        return zod_1.z.function()
            .args(typeSchema_1.stringSchema, typeSchema_1.saveOptionsSchema.optional())
            .returns(zod_1.z.promise(zod_1.z.void()))
            .implement(this.internal_saveAs.bind(this))(filePath, saveOptions);
    }
    /**
     * Saves the PdfDocument to a binary (Buffer)
     * @param saveOptions see {@link SaveOptions}
     */
    saveAsBuffer(saveOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.saveOptionsSchema.optional())
                .returns(zod_1.z.promise(typeSchema_1.bufferSchema))
                .implement(this.internal_saveAsBuffer.bind(this))(saveOptions);
        });
    }
    //#endregion
    //#region compress
    /**
     * Compress existing PDF images using JPG encoding and the specified settings
     * @param imageQuality Quality (1 - 100) to use during compression
     * @param scaleToVisibleSize Scale down the image resolution according to its visible size in the PDF document
     */
    compressSize(imageQuality, scaleToVisibleSize = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield zod_1.z.function()
                .args(typeSchema_1.numberSchema, typeSchema_1.booleanSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_compressSize.bind(this))(imageQuality, scaleToVisibleSize);
        });
    }
    /**
     *  Remove document struct tree information which describes the logical layout of the document.
     *  Removing the "structure tree" can significantly reduce the disk space used by the document.
     *  Removing the "structure tree" of a complicated document can negatively impact text selection.
     */
    compressStructTree() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_compressStructTree();
        });
    }
    //#endregion
    //#region page
    /**
     * Gets information of all pages in the PdfDocument
     */
    getPagesInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_getPagesInfo();
        });
    }
    /**
     * Gets the number of pages in the PdfDocument.
     */
    getPageCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_getPageCount();
        });
    }
    /**
     * Set the page orientation.
     * @param pageRotation see {@link PageRotation}
     * @param options including {@link PdfPageSelection}
     */
    setRotation(pageRotation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pageSchema_1.pageRotationSchema, zod_1.z.object({ pdfPageSelection: typeSchema_1.pdfPageSelectionSchema.optional() }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_setRotation.bind(this))(pageRotation, options);
        });
    }
    /**
     * Resize a page to the specified dimensions
     * @param newSize {@link PdfPaperSize}
     * @param options including {@link PdfPageSelection}
     */
    resize(newSize, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(paperSchema_1.pdfPaperSizeSchema, zod_1.z.object({ pdfPageSelection: typeSchema_1.pdfPageSelectionSchema.optional() }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_resize.bind(this))(newSize, options);
        });
    }
    /**
     * Adds another PDF to the beginning of the current PdfDocument
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to prepend
     */
    prependAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pdfDocumentSchema_1.pdfDocumentSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_prependAnotherPdf.bind(this))(fromPdfDocument);
        });
    }
    /**
     * Appends another PDF to the end of the current <see cref="PdfDocument"/>
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to Append
     */
    appendAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pdfDocumentSchema_1.pdfDocumentSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_appendAnotherPdf.bind(this))(fromPdfDocument);
        });
    }
    /**
     * Inserts another PDF into the current PdfDocument, starting at a given Page Index.
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument Another PdfDocument
     * @param insertAtPageIndex Index at which to insert the new content.  Note: Page 1 has index 0...
     */
    insertPagesFromAnotherPdf(fromPdfDocument, insertAtPageIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pdfDocumentSchema_1.pdfDocumentSchema, typeSchema_1.numberSchema.describe("insertAtPageIndex: number"))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_insertPagesFromAnotherPdf.bind(this))(fromPdfDocument, insertAtPageIndex);
        });
    }
    /**
     * Removes a range of pages from the PDF
     * @param pages pages to remove
     */
    removePage(pages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.pdfPageSelectionSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_removePage.bind(this))(pages);
        });
    }
    /**
     * Creates a new PDF by copying a range of pages from this {@link PdfDocument}.
     * @param pages pages to copy (default "all")
     */
    duplicate(pages = "all") {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.pdfPageSelectionSchema)
                .returns(zod_1.z.promise(pdfDocumentSchema_1.pdfDocumentSchema))
                .implement(this.internal_duplicate.bind(this))(pages);
        });
    }
    //#endregion
    //#region image
    /**
     * Finds all embedded Images from within a specified pages in the PDF and returns them as Buffer
     * @param options including {@link PdfPageSelection}
     */
    extractRawImages(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.object({ fromPages: typeSchema_1.pdfPageSelectionSchema.optional() }).optional())
                .returns(zod_1.z.promise(typeSchema_1.bufferArraySchema))
                .implement(this.internal_extractRawImages.bind(this))(options);
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page.
     *
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images as Buffer[]
     */
    rasterizeToImageBuffers(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.object({
                fromPages: typeSchema_1.pdfPageSelectionSchema.optional(),
                imageType: imageSchema_1.imageTypeSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(typeSchema_1.bufferArraySchema))
                .implement(this.internal_rasterizeToImageBuffers.bind(this))(options);
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page. Running number will append output file path.
     *
     * @param filePath output file path.
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images file name as string[]
     */
    rasterizeToImageFiles(filePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.filePathSchema, zod_1.z.object({
                fromPages: typeSchema_1.pdfPageSelectionSchema.optional(),
                type: imageSchema_1.imageTypeSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(typeSchema_1.stringArraySchema))
                .implement(this.internal_rasterizeToImageFiles.bind(this))(filePath, options);
        });
    }
    //#endregion
    //#region text
    /**
     * Replace the specified old text with new text on a given page
     * @param oldText Old text to remove
     * @param newText New text to add
     * @param onPages Page index to search for old text to replace (default "all")
     */
    replaceText(oldText, newText, onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "oldText: string" }), zod_1.z.string({ description: "newText: string" }), typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_replaceText.bind(this))(oldText, newText, onPages);
        });
    }
    extractText(onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.string()))
                .implement(this.internal_extractText.bind(this))(onPages);
        });
    }
    //#endregion
    //#region pdfA
    /**
     * Convert the current document into the specified PDF-A standard format
     * @param customICC (Optional) Custom color profile file path
     */
    convertToPdfA(customICC) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "customICC: string" }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_convertToPdfA.bind(this))(customICC);
        });
    }
    /**
     * Convert the current document into the specified PDF/UA standard format
     */
    convertToPdfUA() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_convertToPdfUA();
        });
    }
    //#endregion
    //#region metadata
    /**
     * Gets a Map<string, string> of metadata properties
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_getMetadata();
        });
    }
    /**
     * Add or Update a single metadata property
     * @param key
     * @param value
     */
    addOrUpdateMetadata(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "key: string" }), zod_1.z.string({ description: "value: string" }))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addOrUpdateMetadata.bind(this))(key, value);
        });
    }
    /**
     * Remove a single metadata property
     * @param key
     */
    removeMetadata(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "key: string" }))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_removeMetadata.bind(this))(key);
        });
    }
    /**
     * Sets a whole metadata properties Map<string, string> (override all the metadata property)
     * @param newMetadataDictionary new metadata properties Map<string, string>
     */
    overrideMetadata(newMetadataDictionary) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.mapStringSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_overrideMetadata.bind(this))(newMetadataDictionary);
        });
    }
    //#endregion
    //#region signing
    /**
     * Sign PDF with digital signature certificate.
     * Note that the PDF will not be fully signed until Saved
     * using {@link saveAs} or {@link saveAsBuffer}
     *
     * Multiple certificates may be used.
     * @param signature see {@link DigitalSignature}
     */
    signDigitalSignature(signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(signatureSchema_1.digitalSignatureSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_signDigitalSignature.bind(this))(signature);
        });
    }
    /**
     * Check if PdfDocument was signed or not
     */
    isSigned() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_isSigned();
        });
    }
    /**
     * Count the number signature that signed to this PdfDocument
     */
    signatureCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_signatureCount();
        });
    }
    //#endregion
    //#region header/footer (affix)
    /**
     * Apply page header on top of an existing Pdf.
     * @param header {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addTextHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(affixSchema_1.textAffixSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addTextHeader.bind(this))(header, toPages);
        });
    }
    /**
     * Apply page footer on top of an existing Pdf.
     * @param footer {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addTextFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(affixSchema_1.textAffixSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addTextFooter.bind(this))(footer, toPages);
        });
    }
    /**
     * Apply HTML header on top of an existing Pdf.
     * @param header {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addHtmlHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(affixSchema_1.htmlAffixSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addHtmlHeader.bind(this))(header, toPages);
        });
    }
    /**
     * Apply HTML footer on top of an existing Pdf.
     * @param footer {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addHtmlFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(affixSchema_1.htmlAffixSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addHtmlFooter.bind(this))(footer, toPages);
        });
    }
    //#endregion
    //#region stamp
    /**
     * Edits the PDF by applying the HTML's rendered to only selected page(s).
     * @param htmlStringOrHtmlFilePath
     * @param options including {@link HtmlStampOptions} {@link PdfPageSelection}
     */
    stampHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.union([typeSchema_1.htmlFilePathSchema, typeSchema_1.htmlStringSchema]), zod_1.z.object({
                htmlStampOptions: stampSchema_1.htmlStampOptionsSchema.optional(),
                toPages: typeSchema_1.pdfPageSelectionSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_stampHtml.bind(this))(htmlStringOrHtmlFilePath, options);
        });
    }
    /**
     * Edits the PDF by applying the image to only selected page(s).
     * @param image image file path or image buffer
     * @param options including {@link ImageStampOptions} {@link PdfPageSelection}
     */
    stampImage(image, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.union([typeSchema_1.imageFilePathSchema, typeSchema_1.imageBufferSchema]), zod_1.z.object({
                imageStampOptions: stampSchema_1.imageStampOptionsSchema.optional(),
                toPages: typeSchema_1.pdfPageSelectionSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_stampImage.bind(this))(image, options);
        });
    }
    /**
     * Edits the PDF by applying the text to only selected page(s).
     * @param text text to stamp
     * @param options including {@link TextStampOptions} {@link PdfPageSelection}
     */
    stampText(text, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.stringSchema, zod_1.z.object({
                textStampOptions: stampSchema_1.textStampOptionsSchema.optional(),
                toPages: typeSchema_1.pdfPageSelectionSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_stampText.bind(this))(text, options);
        });
    }
    /**
     * Edits the PDF by applying the barcode to only selected page(s).
     * @param barcodeValue barcode
     * @param options including {@link BarcodeType} {@link BarcodeStampOptions} {@link PdfPageSelection}
     */
    stampBarcode(barcodeValue, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(typeSchema_1.stringSchema, zod_1.z.object({
                barcodeEncoding: typeSchema_1.barcodeTypeSchema,
                barcodeStampOptions: stampSchema_1.barcodeStampOptionsSchema.optional(),
                toPages: typeSchema_1.pdfPageSelectionSchema.optional()
            }).optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_stampBarcode.bind(this))(barcodeValue, options);
        });
    }
    //#endregion
    //#region background/foreground
    /**
     * Adds a background to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf background PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    addBackgroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pdfDocumentSchema_1.pdfDocumentSchema, typeSchema_1.numberSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addBackgroundFromAnotherPdf.bind(this))(fromPdf, sourcePageIndex, applyToPages);
        });
    }
    /**
     * Adds a foreground to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf foreground PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    addForegroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(pdfDocumentSchema_1.pdfDocumentSchema, typeSchema_1.numberSchema, typeSchema_1.pdfPageSelectionSchema.optional())
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_addForegroundFromAnotherPdf.bind(this))(fromPdf, sourcePageIndex, applyToPages);
        });
    }
    //#endregion
    //#region security
    /**
     * Removes all user and owner password security for a PDF document.  Also disables content
     * encryption.
     * If content is encrypted at 128 bit, copy and paste of content, annotations and form editing may be disabled.
     */
    removePasswordsAndEncryption() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_removePasswordsAndEncryption();
        });
    }
    /**
     * Sets the user password and enables 128Bit encryption of PDF content.
     * A user password is a password that each user must enter to open or print the PDF document.
     */
    setUserPassword(userPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "userPassword: string" }))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_setUserPassword.bind(this))(userPassword);
        });
    }
    /**
     * Sets the owner password and enables 128Bit encryption of PDF content. An owner password is one used to
     * enable and disable all other security settings. <para>OwnerPassword must be set to a non-empty string
     * value for {@link PdfPermission.AllowAccessibilityExtractContent} ,  {@link PdfPermission.AllowAnnotations} ,
     * {@link PdfPermission.AllowFillForms},  {@link PdfPermission.AllowPrint},  {@link PdfPermission.AllowModify} to be
     * restricted.
     */
    setOwnerPassword(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "ownerPassword: string" }))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_setOwnerPassword.bind(this))(ownerPassword);
        });
    }
    /**
     * Sets the permissions of this PdfDocument
     * @param permissions see {@link PdfPermission}
     */
    setPermission(permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(securitySchema_1.pdfPermissionSchema)
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_setPermission.bind(this))(permissions);
        });
    }
    /**
     * Gets the current permissions of this PdfDocument
     * @return {@link PdfPermission}
     */
    getPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_getPermission();
        });
    }
    /**
     * Makes this PDF document read only such that: Content is encrypted at 128 bit. Copy and paste of
     * content is disallowed. Annotations and form editing are disabled.
     * @param ownerPassword The owner password for the PDF. A string for owner password is required to enable PDF encryption and
     * all document security options.
     */
    makePdfDocumentReadOnly(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            return zod_1.z.function()
                .args(zod_1.z.string({ description: "ownerPassword: string" }))
                .returns(zod_1.z.promise(zod_1.z.void()))
                .implement(this.internal_makePdfDocumentReadOnly.bind(this))(ownerPassword);
        });
    }
    //#endregion
    //#region close
    /**
     * Dispose this PdfDocument object (clean up the resource)
     * This is necessary to free the memory used by PdfDocument. See {@link cleanUp}
     * Once this method was called this PdfDocument object no longer usable.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_close();
        });
    }
    /**
     * Create a PdfDocument object from a {@link PdfInput}
     * For more specific way to create/open PdfDocument see {@link fromUrl} {@link fromZip} {@link fromHtml} {@link fromImage}  {@link open}
     *
     * @param pdfInput see {@link PdfInput} (required)
     * @param password a password to open the PDF required if PDF file was private (pdfInput is {@link PdfFilePath} or {@link Buffer})
     * @param trackChanges Optionally track changes to the document (for use with incremental saves)
     */
    constructor(pdfInput, password, trackChanges) {
        var _a;
        if (pdfInput) {
            this.pdfDocumentId = undefined;
            const input = (0, util_1.separatePdfInput)(pdfInput);
            switch (input.type) {
                case "htmlFile":
                    const htmlString = fs_1.default
                        .readFileSync(input.htmlFile)
                        .toString();
                    this.promiseDocumentId = (0, render_1.renderHtmlToPdf)(htmlString);
                    break;
                case "htmlString":
                    this.promiseDocumentId = (0, render_1.renderHtmlToPdf)(input.htmlString);
                    break;
                case "zipFile":
                    this.promiseDocumentId = (0, render_1.renderHtmlZipToPdf)(input.zipFile);
                    break;
                case "buffer":
                    this.promiseDocumentId = (0, io_1.openPdfFileBuffer)(input.buffer, password);
                    break;
                case "pdfFile":
                    this.pdfPassword = password;
                    this.promiseDocumentId = (0, io_1.openPdfFileBuffer)(fs_1.default.readFileSync(input.pdfFile), password);
                    break;
                case "url":
                    this.promiseDocumentId = (0, render_1.renderUrlToPdf)(input.url);
                    break;
                case "pdfDocument":
                    this.pdfDocumentId = input.pdfDocument.pdfDocumentId;
                    this.promiseDocumentId =
                        input.pdfDocument.promiseDocumentId;
                    break;
            }
            if (this.pdfDocumentId) {
                access_1.Access.usedDocumentIds.add(this.pdfDocumentId);
            }
            (_a = this.promiseDocumentId) === null || _a === void 0 ? void 0 : _a.then((id) => access_1.Access.usedDocumentIds.add(id));
        }
    }
    /**
     * Dispose this PdfDocument object (clean up the resource)
     * This is necessary to free the memory used by PdfDocument. See {@link cleanUp}
     * Once this method was called this PdfDocument object no longer usable.
     */
    internal_close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, io_1.disposePdf)(yield this.internal_getId());
        });
    }
    /**
     * @private
     */
    internal_getId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pdfDocumentId) {
                return Promise.resolve(this.pdfDocumentId);
            }
            else if (this.promiseDocumentId) {
                this.pdfDocumentId = yield this.promiseDocumentId;
                return Promise.resolve(this.pdfDocumentId);
            }
            else {
                throw new Error("Cannot Get PdfDocumentId");
            }
        });
    }
    //#region io
    /**
     * Open or Create a PdfDocument from a {@link PdfInput}
     * @param pdfInput {@link PdfInput}
     * @param options including {@link PdfPassword} {@link ChromePdfRenderOptions} {@link HttpLoginCredentials} mainHtmlFile
     */
    static internal_open(pdfInput, options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (pdfInput) {
                const input = (0, util_1.separatePdfInput)(pdfInput);
                switch (input.type) {
                    case "htmlFile":
                        const htmlString = fs_1.default
                            .readFileSync(input.htmlFile)
                            .toString();
                        const newHtmlFilePdf = new PdfDocument();
                        newHtmlFilePdf.pdfDocumentId = yield (0, render_1.renderHtmlToPdf)(htmlString, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newHtmlFilePdf;
                    case "htmlString":
                        const newHtmlStringPdf = new PdfDocument();
                        newHtmlStringPdf.pdfDocumentId = yield (0, render_1.renderHtmlToPdf)(input.htmlString, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newHtmlStringPdf;
                    case "zipFile":
                        const newZipFilePdf = new PdfDocument();
                        newZipFilePdf.pdfDocumentId = yield (0, render_1.renderHtmlZipToPdf)(input.zipFile, options === null || options === void 0 ? void 0 : options.mainHtmlFile, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newZipFilePdf;
                    case "buffer":
                        const newBufferPdf = new PdfDocument(undefined, options === null || options === void 0 ? void 0 : options.password, options === null || options === void 0 ? void 0 : options.trackChanges);
                        newBufferPdf.pdfDocumentId = yield (0, io_1.openPdfFileBuffer)(input.buffer, {
                            userPassword: (_a = options === null || options === void 0 ? void 0 : options.password) === null || _a === void 0 ? void 0 : _a.userPassword,
                            ownerPassword: (_b = options === null || options === void 0 ? void 0 : options.password) === null || _b === void 0 ? void 0 : _b.ownerPassword,
                            trackChanges: options === null || options === void 0 ? void 0 : options.trackChanges
                        });
                        return newBufferPdf;
                    case "pdfFile":
                        const newPdfFilePdf = new PdfDocument(undefined, options === null || options === void 0 ? void 0 : options.password);
                        newPdfFilePdf.pdfDocumentId = yield (0, io_1.openPdfFileBuffer)(fs_1.default.readFileSync(input.pdfFile), {
                            userPassword: (_c = options === null || options === void 0 ? void 0 : options.password) === null || _c === void 0 ? void 0 : _c.userPassword,
                            ownerPassword: (_d = options === null || options === void 0 ? void 0 : options.password) === null || _d === void 0 ? void 0 : _d.ownerPassword,
                            trackChanges: options === null || options === void 0 ? void 0 : options.trackChanges
                        });
                        return newPdfFilePdf;
                    case "url":
                        const newUrlPdf = new PdfDocument();
                        newUrlPdf.pdfDocumentId = yield (0, render_1.renderUrlToPdf)(input.url, {
                            renderOptions: options === null || options === void 0 ? void 0 : options.renderOptions,
                            httpLoginCredentials: options === null || options === void 0 ? void 0 : options.httpLoginCredentials,
                        });
                        return newUrlPdf;
                    case "pdfDocument":
                        return Promise.resolve(input.pdfDocument);
                }
            }
            throw new Error(`cannot create PdfDocument object from ${pdfInput}`);
        });
    }
    /**
     * Open a PdfDocument from .pdf file
     * @param pdfFilePath A path to .pdf file
     * @param Optionally track changes to the document (for use with incremental saves)
     */
    static internal_fromFile(pdfFilePath, trackChanges) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_open(pdfFilePath, { trackChanges: trackChanges });
        });
    }
    /**
     * Create a PdfDocument from an Url
     * @param url A website Url
     * @param options including {@link ChromePdfRenderOptions}
     */
    static internal_fromUrl(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_open(url, options);
        });
    }
    /**
     * Creates a PDF file from a local Zip file, and returns it as a {@link PdfDocument}.
     * IronPDF is a W3C standards compliant HTML rendering based on Google's Chromium browser.
     * If your output PDF does not look as expected:
     *
     * - Validate your HTML file using  https://validator.w3.org/ &amp; CSS https://jigsaw.w3.org/css-validator/
     *
     * - To debug HTML, view the file in Chrome web browser's print preview which will work almost exactly as IronPDF.
     *
     * - Read our detailed documentation on pixel perfect HTML to PDF: https://ironpdf.com/tutorials/pixel-perfect-html-to-pdf/
     *
     * @param zipFilePath Path to a Zip to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions} and `mainHtmlFile` a main .html file default: `index.html`
     */
    static internal_fromZip(zipFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_open(zipFilePath, options);
        });
    }
    /**
     * Creates a PDF file from a Html string, and returns it as an {@link PdfDocument} object which can be edited and saved to disk or served on a website.
     * @param htmlStringOrHtmlFilePath The Html to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions}
     */
    static internal_fromHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_open(htmlStringOrHtmlFilePath, options);
        });
    }
    /**
     *  Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image
     *  dimensions. The default PaperSize is A4. You can set it via ImageToPdfConverter.PaperSize.
     *  Note: Imaging.ImageBehavior.CropPage will set PaperSize equal to ImageSize.
     * @param images The image file path name(s) or {@link ImageBuffer} object(s)
     * @param options including {@link ImageToPdfOptions}
     */
    static internal_fromImage(images, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let temp;
            if (Array.isArray(images)) {
                // const imageArray = images as Array<any>;
                if (images.length == 0) {
                    throw new Error("imageToPdf input Array is Empty");
                }
                const t = (0, util_1.separateImageBufferOrImagePathInput)(images[0]);
                switch (t.type) {
                    case "imageBuffer":
                        temp = (0, image_1.renderImagesBufferToPdf)(images, options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                    case "imageFilePath":
                        temp = (0, image_1.renderImagesFilesToPdf)(images, options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                }
            }
            else {
                const image = (0, util_1.separateImageBufferOrImagePathInput)(images);
                switch (image.type) {
                    case "imageBuffer":
                        temp = (0, image_1.renderImagesBufferToPdf)([image.imageBuffer], options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                    case "imageFilePath":
                        temp = (0, image_1.renderImagesFilesToPdf)([image.imageFilePath], options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                }
            }
            if (!temp) {
                throw new Error(`cannot read image: ${images}`);
            }
            const newUrlPdf = new PdfDocument();
            newUrlPdf.pdfDocumentId = yield temp;
            return newUrlPdf;
        });
    }
    /**
     * Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document.
     * If the PDF contains form fields the form field in the resulting PDF's name will be appended with '_{index}' e.g. 'Name' will be 'Name_0'
     * @param pdfs array of PDF
     */
    static internal_mergePdf(pdfs) {
        return __awaiter(this, void 0, void 0, function* () {
            const ids = yield Promise.all(pdfs.map((x) => __awaiter(this, void 0, void 0, function* () { return (yield PdfDocument.open(x)).internal_getId(); })));
            const newDocId = (0, render_1.mergePdfs)(ids);
            const newUrlPdf = new PdfDocument();
            newUrlPdf.pdfDocumentId = yield newDocId;
            return newUrlPdf;
        });
    }
    /**
     * Saves the PdfDocument to a file.
     * @param filePath Target file path
     * @param saveOptions see {@link SaveOptions}
     */
    internal_saveAs(filePath, saveOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.internal_saveAsBuffer(saveOptions).then((pdfFileBuffer) => {
                fs_1.default.writeFile(filePath, pdfFileBuffer, "binary", (err) => {
                    if (err)
                        throw err;
                });
            });
        });
    }
    /**
     * Saves the PdfDocument to a binary (Buffer)
     * @param saveOptions see {@link SaveOptions}
     */
    internal_saveAsBuffer(saveOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, io_1.getBinaryData)(yield this.internal_getId(), saveOptions);
        });
    }
    //#endregion
    //#region compress
    /**
     * Compress existing PDF images using JPG encoding and the specified settings
     * @param imageQuality Quality (1 - 100) to use during compression
     * @param scaleToVisibleSize Scale down the image resolution according to its visible size in the PDF document
     */
    internal_compressSize(imageQuality, scaleToVisibleSize = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (imageQuality < 1 || imageQuality > 100)
                throw new Error(`Invalid quality specifier (${imageQuality}) when compressing images. Quality must be between 1 and 100.`);
            return yield (0, compress_1.compressImage)(yield this.internal_getId(), imageQuality, scaleToVisibleSize);
        });
    }
    /**
     *  Remove document struct tree information which describes the logical layout of the document.
     *  Removing the "structure tree" can significantly reduce the disk space used by the document.
     *  Removing the "structure tree" of a complicated document can negatively impact text selection.
     */
    internal_compressStructTree() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, compress_1.compressStructTree)(yield this.internal_getId());
        });
    }
    //#endregion
    //#region page
    /**
     * Gets information of all pages in the PdfDocument
     */
    internal_getPagesInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.getPageInfo)(yield this.internal_getId());
        });
    }
    /**
     * Gets the number of pages in the PdfDocument.
     */
    internal_getPageCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.internal_getPagesInfo()).length;
        });
    }
    /**
     * Set the page orientation.
     * @param pageRotation see {@link PageRotation}
     * @param options including {@link PdfPageSelection}
     */
    internal_setRotation(pageRotation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.setPageRotation)(yield this.internal_getId(), pageRotation, options);
        });
    }
    /**
     * Resize a page to the specified dimensions
     * @param newSize {@link PdfPaperSize}
     * @param options including {@link PdfPageSelection}
     */
    internal_resize(newSize, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.resizePage)(yield this.internal_getId(), newSize, options);
        });
    }
    /**
     * Adds another PDF to the beginning of the current PdfDocument
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to prepend
     */
    internal_prependAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.internal_insertPagesFromAnotherPdf(fromPdfDocument, 0);
        });
    }
    /**
     * Appends another PDF to the end of the current <see cref="PdfDocument"/>
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to Append
     */
    internal_appendAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.internal_insertPagesFromAnotherPdf(fromPdfDocument, (yield this.internal_getPageCount()) - 1);
        });
    }
    /**
     * Inserts another PDF into the current PdfDocument, starting at a given Page Index.
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument Another PdfDocument
     * @param insertAtPageIndex Index at which to insert the new content.  Note: Page 1 has index 0...
     */
    internal_insertPagesFromAnotherPdf(fromPdfDocument, insertAtPageIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, page_1.insertPdf)(yield this.internal_getId(), yield fromPdfDocument.internal_getId(), insertAtPageIndex);
        });
    }
    /**
     * Removes a range of pages from the PDF
     * @param pages pages to remove
     */
    internal_removePage(pages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, page_1.removePage)(yield this.internal_getId(), { PdfPageSelection: pages });
        });
    }
    /**
     * Creates a new PDF by copying a range of pages from this {@link PdfDocument}.
     * @param pages pages to copy (default "all")
     */
    internal_duplicate(pages = "all") {
        return __awaiter(this, void 0, void 0, function* () {
            const newPdf = new PdfDocument();
            newPdf.pdfDocumentId = yield (0, page_1.duplicate)(yield this.internal_getId(), {
                PdfPageSelection: pages,
            });
            return newPdf;
        });
    }
    //#endregion
    //#region image
    /**
     * Finds all embedded Images from within a specified pages in the PDF and returns them as Buffer
     * @param options including {@link PdfPageSelection}
     */
    internal_extractRawImages(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (0, image_2.extractRawImages)(yield this.internal_getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page.
     *
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images as Buffer[]
     */
    internal_rasterizeToImageBuffers(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const images = yield (0, image_2.rasterizeToImageBuffers)(yield this.internal_getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
            const jimpImageType = (() => {
                switch (options === null || options === void 0 ? void 0 : options.imageType) {
                    case types_1.ImageType.BMP:
                        return jimp_1.default.MIME_BMP;
                    case types_1.ImageType.PNG:
                        return jimp_1.default.MIME_PNG;
                    case types_1.ImageType.JPG:
                        return jimp_1.default.MIME_JPEG;
                    default:
                        return jimp_1.default.MIME_PNG;
                }
            })();
            return Promise.all(images.map((imageBuffer) => __awaiter(this, void 0, void 0, function* () {
                //convert output type
                const jimp = yield jimp_1.default.read(imageBuffer);
                return yield jimp.getBufferAsync(jimpImageType);
            })));
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page. Running number will append output file path.
     *
     * @param filePath output file path.
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images file name as string[]
     */
    internal_rasterizeToImageFiles(filePath, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const images = yield (0, image_2.rasterizeToImageBuffers)(yield this.internal_getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
            const filesName = (0, util_1.getFileNames)(filePath, images.length, (0, util_1.getImageExtType)(options === null || options === void 0 ? void 0 : options.type), "image");
            const promises = images.map((imageBuffer, index) => __awaiter(this, void 0, void 0, function* () {
                yield jimp_1.default.read(imageBuffer).then((value) => value.write(filesName[index]));
                return filesName[index];
            }));
            return yield Promise.all(promises);
        });
    }
    //#endregion
    //#region text
    /**
     * Replace the specified old text with new text on a given page
     * @param oldText Old text to remove
     * @param newText New text to add
     * @param onPages Page index to search for old text to replace (default "all")
     */
    internal_replaceText(oldText, newText, onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, text_1.replaceText)(yield this.internal_getId(), oldText, newText, onPages);
        });
    }
    internal_extractText(onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, text_1.extractAllText)(yield this.internal_getId(), onPages);
        });
    }
    //#endregion
    //#region pdfA
    /**
     * Convert the current document into the specified PDF-A standard format
     * @param customICC (Optional) Custom color profile file path
     */
    internal_convertToPdfA(customICC) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, pdfa_1.toPdfA)(yield this.internal_getId(), customICC);
        });
    }
    /**
     * Convert the current document into the specified PDF/UA standard format
     */
    internal_convertToPdfUA() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, pdfa_1.toPdfUA)(yield this.internal_getId());
        });
    }
    //#endregion
    //#region metadata
    /**
     * Gets a Map<string, string> of metadata properties
     */
    internal_getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.getMetadataDict)(yield this.internal_getId());
        });
    }
    /**
     * Add or Update a single metadata property
     * @param key
     * @param value
     */
    internal_addOrUpdateMetadata(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.setMetadata)(yield this.internal_getId(), key, value);
        });
    }
    /**
     * Remove a single metadata property
     * @param key
     */
    internal_removeMetadata(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.removeMetadata)(yield this.internal_getId(), key);
        });
    }
    /**
     * Sets a whole metadata properties Map<string, string> (override all the metadata property)
     * @param newMetadataDictionary new metadata properties Map<string, string>
     */
    internal_overrideMetadata(newMetadataDictionary) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.setMetadataDict)(yield this.internal_getId(), newMetadataDictionary);
        });
    }
    //#endregion
    //#region signing
    /**
     * Sign PDF with digital signature certificate.
     * Note that the PDF will not be fully signed until Saved
     * using {@link saveAs} or {@link saveAsBuffer}
     *
     * Multiple certificates may be used.
     * @param signature see {@link DigitalSignature}
     */
    internal_signDigitalSignature(signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, signing_1.signPdf)(yield this.internal_getId(), signature);
        });
    }
    /**
     * Check if PdfDocument was signed or not
     */
    internal_isSigned() {
        return __awaiter(this, void 0, void 0, function* () {
            const signatureCount = yield (0, signing_1.getSignatureCount)(yield this.internal_getId());
            return signatureCount > 0;
        });
    }
    /**
     * Count the number signature that signed to this PdfDocument
     */
    internal_signatureCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, signing_1.getSignatureCount)(yield this.internal_getId());
        });
    }
    //#endregion
    //#region header/footer (affix)
    /**
     * Apply page header on top of an existing Pdf.
     * @param header {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    internal_addTextHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addTextAffix)(yield this.internal_getId(), toPages, header, true);
        });
    }
    /**
     * Apply page footer on top of an existing Pdf.
     * @param footer {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    internal_addTextFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addTextAffix)(yield this.internal_getId(), toPages, footer, false);
        });
    }
    /**
     * Apply HTML header on top of an existing Pdf.
     * @param header {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    internal_addHtmlHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addHtmlAffix)(yield this.internal_getId(), toPages, header, true);
        });
    }
    /**
     * Apply HTML footer on top of an existing Pdf.
     * @param footer {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    internal_addHtmlFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addHtmlAffix)(yield this.internal_getId(), toPages, footer, false);
        });
    }
    //#endregion
    //#region stamp
    /**
     * Edits the PDF by applying the HTML's rendered to only selected page(s).
     * @param htmlStringOrHtmlFilePath
     * @param options including {@link HtmlStampOptions} {@link PdfPageSelection}
     */
    internal_stampHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const html = htmlStringOrHtmlFilePath.endsWith(".html") ||
                htmlStringOrHtmlFilePath.endsWith(".htm")
                ? fs_1.default.readFileSync(htmlStringOrHtmlFilePath).toString()
                : htmlStringOrHtmlFilePath;
            yield (0, stamp_1.stampHtml)(yield this.internal_getId(), html, {
                password: this.pdfPassword,
                htmlStampOptions: options === null || options === void 0 ? void 0 : options.htmlStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the image to only selected page(s).
     * @param image image file path or image buffer
     * @param options including {@link ImageStampOptions} {@link PdfPageSelection}
     */
    internal_stampImage(image, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const imageBuffer = image instanceof buffer_1.Buffer ? image : fs_1.default.readFileSync(image);
            yield (0, stamp_1.stampImage)(yield this.internal_getId(), imageBuffer, {
                password: this.pdfPassword,
                imageStampOptions: options === null || options === void 0 ? void 0 : options.imageStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the text to only selected page(s).
     * @param text text to stamp
     * @param options including {@link TextStampOptions} {@link PdfPageSelection}
     */
    internal_stampText(text, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, stamp_1.stampText)(yield this.internal_getId(), text, {
                password: this.pdfPassword,
                textStampOptions: options === null || options === void 0 ? void 0 : options.textStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the barcode to only selected page(s).
     * @param barcodeValue barcode
     * @param options including {@link BarcodeType} {@link BarcodeStampOptions} {@link PdfPageSelection}
     */
    internal_stampBarcode(barcodeValue, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, stamp_1.stampBarcode)(yield this.internal_getId(), barcodeValue, {
                password: this.pdfPassword,
                barcodeStampOptions: options === null || options === void 0 ? void 0 : options.barcodeStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    //#endregion
    //#region background/foreground
    /**
     * Adds a background to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf background PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    internal_addBackgroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, BackgroundForeground_1.addBackgroundForeground)(yield this.internal_getId(), yield fromPdf.internal_getId(), sourcePageIndex, true, applyToPages);
        });
    }
    /**
     * Adds a foreground to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf foreground PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    internal_addForegroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, BackgroundForeground_1.addBackgroundForeground)(yield this.internal_getId(), yield fromPdf.internal_getId(), sourcePageIndex, false, applyToPages);
        });
    }
    //#endregion
    //#region security
    /**
     * Removes all user and owner password security for a PDF document.  Also disables content
     * encryption.
     * If content is encrypted at 128 bit, copy and paste of content, annotations and form editing may be disabled.
     */
    internal_removePasswordsAndEncryption() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, security_1.removePasswordsAndEncryption)(yield this.internal_getId());
        });
    }
    /**
     * Sets the user password and enables 128Bit encryption of PDF content.
     * A user password is a password that each user must enter to open or print the PDF document.
     */
    internal_setUserPassword(userPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pdfPassword)
                this.pdfPassword = { userPassword: userPassword };
            else
                this.pdfPassword.userPassword = userPassword;
            this.pdfDocumentId = yield (0, security_1.setUserPasswords)(yield this.internal_getId(), userPassword);
        });
    }
    /**
     * Sets the owner password and enables 128Bit encryption of PDF content. An owner password is one used to
     * enable and disable all other security settings. <para>OwnerPassword must be set to a non-empty string
     * value for {@link PdfPermission.AllowAccessibilityExtractContent} ,  {@link PdfPermission.AllowAnnotations} ,
     * {@link PdfPermission.AllowFillForms},  {@link PdfPermission.AllowPrint},  {@link PdfPermission.AllowModify} to be
     * restricted.
     */
    internal_setOwnerPassword(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pdfPassword)
                this.pdfPassword = { ownerPassword: ownerPassword };
            else
                this.pdfPassword.ownerPassword = ownerPassword;
            this.pdfDocumentId = yield (0, security_1.setOwnerPasswords)(yield this.internal_getId(), ownerPassword);
        });
    }
    /**
     * Sets the permissions of this PdfDocument
     * @param permissions see {@link PdfPermission}
     */
    internal_setPermission(permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.pdfDocumentId = yield (0, security_1.setSecurity)(yield this.internal_getId(), permissions);
        });
    }
    /**
     * Gets the current permissions of this PdfDocument
     * @return {@link PdfPermission}
     */
    internal_getPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, security_1.getPermission)(yield this.internal_getId());
        });
    }
    /**
     * Makes this PDF document read only such that: Content is encrypted at 128 bit. Copy and paste of
     * content is disallowed. Annotations and form editing are disabled.
     * @param ownerPassword The owner password for the PDF. A string for owner password is required to enable PDF encryption and
     * all document security options.
     */
    internal_makePdfDocumentReadOnly(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.internal_setOwnerPassword(ownerPassword);
            yield this.internal_setPermission({
                AllowExtractContent: false,
                AllowAccessibilityExtractContent: false,
                AllowAnnotations: false,
                AllowModify: false,
                AllowAssembleDocument: false,
                AllowFillForms: false,
            });
        });
    }
}
exports.PdfDocument = PdfDocument;
//# sourceMappingURL=pdfDocument.js.map